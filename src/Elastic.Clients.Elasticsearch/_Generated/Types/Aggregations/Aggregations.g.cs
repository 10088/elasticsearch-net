// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information.
//
// ███╗   ██╗ ██████╗ ████████╗██╗ ██████╗███████╗
// ████╗  ██║██╔═══██╗╚══██╔══╝██║██╔════╝██╔════╝
// ██╔██╗ ██║██║   ██║   ██║   ██║██║     █████╗
// ██║╚██╗██║██║   ██║   ██║   ██║██║     ██╔══╝
// ██║ ╚████║╚██████╔╝   ██║   ██║╚██████╗███████╗
// ╚═╝  ╚═══╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝╚══════╝
// ------------------------------------------------
//
// This file is automatically generated.
// Please do not edit these files manually.
//
// ------------------------------------------------

using Elastic.Transport.Products.Elasticsearch.Failures;
using OneOf;
using System;
using System.Collections.Generic;
using System.Text.Json.Serialization;

#nullable restore
namespace Elastic.Clients.Elasticsearch.Aggregations
{
	[ConvertAs(typeof(AdjacencyMatrixAggregation))]
	public partial interface IAdjacencyMatrixAggregation
	{
		Dictionary<string, Elastic.Clients.Elasticsearch.QueryDsl.IQueryContainer>? Filters { get; set; }
	}

	public partial class AdjacencyMatrixAggregationDescriptor : DescriptorBase<AdjacencyMatrixAggregationDescriptor, IAdjacencyMatrixAggregation>, IAdjacencyMatrixAggregation
	{
		Dictionary<string, Elastic.Clients.Elasticsearch.QueryDsl.IQueryContainer>? IAdjacencyMatrixAggregation.Filters { get; set; }
	}

	public partial class AdjacencyMatrixAggregation : Aggregations.BucketAggregationBase, IAdjacencyMatrixAggregation
	{
		[JsonInclude]
		[JsonPropertyName("filters")]
		public Dictionary<string, Elastic.Clients.Elasticsearch.QueryDsl.IQueryContainer>? Filters { get; set; }
	}

	public abstract partial class AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("meta")]
		public Dictionary<string, object>? Meta
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	[ConvertAs(typeof(Aggregation))]
	public partial interface IAggregation
	{
		Dictionary<string, object>? Meta { get; set; }

		string? Name { get; set; }
	}

	public partial class AggregationDescriptor : DescriptorBase<AggregationDescriptor, IAggregation>, IAggregation
	{
		Dictionary<string, object>? IAggregation.Meta { get; set; }

		string? IAggregation.Name { get; set; }
	}

	public partial class Aggregation : IAggregation
	{
		[JsonInclude]
		[JsonPropertyName("meta")]
		public Dictionary<string, object>? Meta { get; set; }

		[JsonInclude]
		[JsonPropertyName("name")]
		public string? Name { get; set; }
	}

	[ConvertAs(typeof(AggregationRange))]
	public partial interface IAggregationRange
	{
		Union<double, string>? From { get; set; }

		string? Key { get; set; }

		Union<double, string>? To { get; set; }
	}

	public partial class AggregationRangeDescriptor : DescriptorBase<AggregationRangeDescriptor, IAggregationRange>, IAggregationRange
	{
		Union<double, string>? IAggregationRange.From { get; set; }

		string? IAggregationRange.Key { get; set; }

		Union<double, string>? IAggregationRange.To { get; set; }
	}

	public partial class AggregationRange : IAggregationRange
	{
		[JsonInclude]
		[JsonPropertyName("from")]
		public Union<double, string>? From { get; set; }

		[JsonInclude]
		[JsonPropertyName("key")]
		public string? Key { get; set; }

		[JsonInclude]
		[JsonPropertyName("to")]
		public Union<double, string>? To { get; set; }
	}

	public partial class AutoDateHistogramAggregate<TBucket> : Aggregations.MultiBucketAggregate<TBucket>
	{
		[JsonInclude]
		[JsonPropertyName("interval")]
		public Elastic.Clients.Elasticsearch.DateMathTime Interval
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	[ConvertAs(typeof(AutoDateHistogramAggregation))]
	public partial interface IAutoDateHistogramAggregation
	{
		int? Buckets { get; set; }

		Elastic.Clients.Elasticsearch.Field? Field { get; set; }

		string? Format { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.MinimumInterval? MinimumInterval { get; set; }

		Elastic.Clients.Elasticsearch.DateString? Missing { get; set; }

		string? Offset { get; set; }

		Dictionary<string, object>? Params { get; set; }

		Elastic.Clients.Elasticsearch.Script? Script { get; set; }

		string? TimeZone { get; set; }
	}

	public partial class AutoDateHistogramAggregationDescriptor : DescriptorBase<AutoDateHistogramAggregationDescriptor, IAutoDateHistogramAggregation>, IAutoDateHistogramAggregation
	{
		int? IAutoDateHistogramAggregation.Buckets { get; set; }

		Elastic.Clients.Elasticsearch.Field? IAutoDateHistogramAggregation.Field { get; set; }

		string? IAutoDateHistogramAggregation.Format { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.MinimumInterval? IAutoDateHistogramAggregation.MinimumInterval { get; set; }

		Elastic.Clients.Elasticsearch.DateString? IAutoDateHistogramAggregation.Missing { get; set; }

		string? IAutoDateHistogramAggregation.Offset { get; set; }

		Dictionary<string, object>? IAutoDateHistogramAggregation.Params { get; set; }

		Elastic.Clients.Elasticsearch.Script? IAutoDateHistogramAggregation.Script { get; set; }

		string? IAutoDateHistogramAggregation.TimeZone { get; set; }
	}

	public partial class AutoDateHistogramAggregation : Aggregations.BucketAggregationBase, IAutoDateHistogramAggregation
	{
		[JsonInclude]
		[JsonPropertyName("buckets")]
		public int? Buckets { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public Elastic.Clients.Elasticsearch.Field? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("format")]
		public string? Format { get; set; }

		[JsonInclude]
		[JsonPropertyName("minimum_interval")]
		public Elastic.Clients.Elasticsearch.Aggregations.MinimumInterval? MinimumInterval { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing")]
		public Elastic.Clients.Elasticsearch.DateString? Missing { get; set; }

		[JsonInclude]
		[JsonPropertyName("offset")]
		public string? Offset { get; set; }

		[JsonInclude]
		[JsonPropertyName("params")]
		public Dictionary<string, object>? Params { get; set; }

		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script? Script { get; set; }

		[JsonInclude]
		[JsonPropertyName("time_zone")]
		public string? TimeZone { get; set; }
	}

	[ConvertAs(typeof(AverageAggregation))]
	public partial interface IAverageAggregation
	{
	}

	public partial class AverageAggregationDescriptor : DescriptorBase<AverageAggregationDescriptor, IAverageAggregation>, IAverageAggregation
	{
	}

	public partial class AverageAggregation : Aggregations.FormatMetricAggregationBase, IAverageAggregation
	{
	}

	[ConvertAs(typeof(AverageBucketAggregation))]
	public partial interface IAverageBucketAggregation
	{
	}

	public partial class AverageBucketAggregationDescriptor : DescriptorBase<AverageBucketAggregationDescriptor, IAverageBucketAggregation>, IAverageBucketAggregation
	{
	}

	public partial class AverageBucketAggregation : Aggregations.PipelineAggregationBase, IAverageBucketAggregation
	{
	}

	public partial class BoxPlotAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("max")]
		public double Max
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("min")]
		public double Min
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("q1")]
		public double Q1
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("q2")]
		public double Q2
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("q3")]
		public double Q3
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	[ConvertAs(typeof(BoxplotAggregation))]
	public partial interface IBoxplotAggregation
	{
		double? Compression { get; set; }
	}

	public partial class BoxplotAggregationDescriptor : DescriptorBase<BoxplotAggregationDescriptor, IBoxplotAggregation>, IBoxplotAggregation
	{
		double? IBoxplotAggregation.Compression { get; set; }
	}

	public partial class BoxplotAggregation : Aggregations.MetricAggregationBase, IBoxplotAggregation
	{
		[JsonInclude]
		[JsonPropertyName("compression")]
		public double? Compression { get; set; }
	}

	public partial class BucketAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("after_key")]
		public Dictionary<string, object> AfterKey
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("bg_count")]
		public long BgCount
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("doc_count")]
		public long DocCount
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("doc_count_error_upper_bound")]
		public long DocCountErrorUpperBound
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("interval")]
		public Elastic.Clients.Elasticsearch.DateMathTime Interval
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("items")]
		public Elastic.Clients.Elasticsearch.Aggregations.Bucket Items
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("sum_other_doc_count")]
		public long SumOtherDocCount
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	[ConvertAs(typeof(BucketAggregationBase))]
	public partial interface IBucketAggregationBase
	{
		Dictionary<string, Elastic.Clients.Elasticsearch.Aggregations.AggregationContainer>? Aggregations { get; set; }
	}

	public partial class BucketAggregationBaseDescriptor : DescriptorBase<BucketAggregationBaseDescriptor, IBucketAggregationBase>, IBucketAggregationBase
	{
		Dictionary<string, Elastic.Clients.Elasticsearch.Aggregations.AggregationContainer>? IBucketAggregationBase.Aggregations { get; set; }
	}

	public abstract partial class BucketAggregationBase : Aggregations.Aggregation, IBucketAggregationBase
	{
		[JsonInclude]
		[JsonPropertyName("aggregations")]
		public Dictionary<string, Elastic.Clients.Elasticsearch.Aggregations.AggregationContainer>? Aggregations { get; set; }
	}

	[ConvertAs(typeof(BucketScriptAggregation))]
	public partial interface IBucketScriptAggregation
	{
		Elastic.Clients.Elasticsearch.Script? Script { get; set; }
	}

	public partial class BucketScriptAggregationDescriptor : DescriptorBase<BucketScriptAggregationDescriptor, IBucketScriptAggregation>, IBucketScriptAggregation
	{
		Elastic.Clients.Elasticsearch.Script? IBucketScriptAggregation.Script { get; set; }
	}

	public partial class BucketScriptAggregation : Aggregations.PipelineAggregationBase, IBucketScriptAggregation
	{
		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script? Script { get; set; }
	}

	[ConvertAs(typeof(BucketSelectorAggregation))]
	public partial interface IBucketSelectorAggregation
	{
		Elastic.Clients.Elasticsearch.Script? Script { get; set; }
	}

	public partial class BucketSelectorAggregationDescriptor : DescriptorBase<BucketSelectorAggregationDescriptor, IBucketSelectorAggregation>, IBucketSelectorAggregation
	{
		Elastic.Clients.Elasticsearch.Script? IBucketSelectorAggregation.Script { get; set; }
	}

	public partial class BucketSelectorAggregation : Aggregations.PipelineAggregationBase, IBucketSelectorAggregation
	{
		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script? Script { get; set; }
	}

	[ConvertAs(typeof(BucketSortAggregation))]
	public partial interface IBucketSortAggregation
	{
		int? From { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.GapPolicy? GapPolicy { get; set; }

		int? Size { get; set; }

		Elastic.Clients.Elasticsearch.Global.Search.Sort? Sort { get; set; }
	}

	public partial class BucketSortAggregationDescriptor : DescriptorBase<BucketSortAggregationDescriptor, IBucketSortAggregation>, IBucketSortAggregation
	{
		int? IBucketSortAggregation.From { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.GapPolicy? IBucketSortAggregation.GapPolicy { get; set; }

		int? IBucketSortAggregation.Size { get; set; }

		Elastic.Clients.Elasticsearch.Global.Search.Sort? IBucketSortAggregation.Sort { get; set; }
	}

	public partial class BucketSortAggregation : Aggregations.Aggregation, IBucketSortAggregation
	{
		[JsonInclude]
		[JsonPropertyName("from")]
		public int? From { get; set; }

		[JsonInclude]
		[JsonPropertyName("gap_policy")]
		public Elastic.Clients.Elasticsearch.Aggregations.GapPolicy? GapPolicy { get; set; }

		[JsonInclude]
		[JsonPropertyName("size")]
		public int? Size { get; set; }

		[JsonInclude]
		[JsonPropertyName("sort")]
		public Elastic.Clients.Elasticsearch.Global.Search.Sort? Sort { get; set; }
	}

	[ConvertAs(typeof(BucketsPath))]
	public partial interface IBucketsPath
	{
	}

	public partial class BucketsPathDescriptor : DescriptorBase<BucketsPathDescriptor, IBucketsPath>, IBucketsPath
	{
	}

	public partial class BucketsPath : IBucketsPath
	{
	}

	[ConvertAs(typeof(CardinalityAggregation))]
	public partial interface ICardinalityAggregation
	{
		int? PrecisionThreshold { get; set; }

		bool? Rehash { get; set; }
	}

	public partial class CardinalityAggregationDescriptor : DescriptorBase<CardinalityAggregationDescriptor, ICardinalityAggregation>, ICardinalityAggregation
	{
		int? ICardinalityAggregation.PrecisionThreshold { get; set; }

		bool? ICardinalityAggregation.Rehash { get; set; }
	}

	public partial class CardinalityAggregation : Aggregations.MetricAggregationBase, ICardinalityAggregation
	{
		[JsonInclude]
		[JsonPropertyName("precision_threshold")]
		public int? PrecisionThreshold { get; set; }

		[JsonInclude]
		[JsonPropertyName("rehash")]
		public bool? Rehash { get; set; }
	}

	[ConvertAs(typeof(ChiSquareHeuristic))]
	public partial interface IChiSquareHeuristic
	{
		bool BackgroundIsSuperset { get; set; }

		bool IncludeNegatives { get; set; }
	}

	public partial class ChiSquareHeuristicDescriptor : DescriptorBase<ChiSquareHeuristicDescriptor, IChiSquareHeuristic>, IChiSquareHeuristic
	{
		bool IChiSquareHeuristic.BackgroundIsSuperset { get; set; }

		bool IChiSquareHeuristic.IncludeNegatives { get; set; }
	}

	public partial class ChiSquareHeuristic : IChiSquareHeuristic
	{
		[JsonInclude]
		[JsonPropertyName("background_is_superset")]
		public bool BackgroundIsSuperset { get; set; }

		[JsonInclude]
		[JsonPropertyName("include_negatives")]
		public bool IncludeNegatives { get; set; }
	}

	[ConvertAs(typeof(ChildrenAggregation))]
	public partial interface IChildrenAggregation
	{
		Elastic.Clients.Elasticsearch.RelationName? Type { get; set; }
	}

	public partial class ChildrenAggregationDescriptor : DescriptorBase<ChildrenAggregationDescriptor, IChildrenAggregation>, IChildrenAggregation
	{
		Elastic.Clients.Elasticsearch.RelationName? IChildrenAggregation.Type { get; set; }
	}

	public partial class ChildrenAggregation : Aggregations.BucketAggregationBase, IChildrenAggregation
	{
		[JsonInclude]
		[JsonPropertyName("type")]
		public Elastic.Clients.Elasticsearch.RelationName? Type { get; set; }
	}

	[ConvertAs(typeof(ClassificationInferenceOptions))]
	public partial interface IClassificationInferenceOptions
	{
		int? NumTopClasses { get; set; }

		int? NumTopFeatureImportanceValues { get; set; }

		string? PredictionFieldType { get; set; }

		string? ResultsField { get; set; }

		string? TopClassesResultsField { get; set; }
	}

	public partial class ClassificationInferenceOptionsDescriptor : DescriptorBase<ClassificationInferenceOptionsDescriptor, IClassificationInferenceOptions>, IClassificationInferenceOptions
	{
		int? IClassificationInferenceOptions.NumTopClasses { get; set; }

		int? IClassificationInferenceOptions.NumTopFeatureImportanceValues { get; set; }

		string? IClassificationInferenceOptions.PredictionFieldType { get; set; }

		string? IClassificationInferenceOptions.ResultsField { get; set; }

		string? IClassificationInferenceOptions.TopClassesResultsField { get; set; }
	}

	public partial class ClassificationInferenceOptions : IClassificationInferenceOptions
	{
		[JsonInclude]
		[JsonPropertyName("num_top_classes")]
		public int? NumTopClasses { get; set; }

		[JsonInclude]
		[JsonPropertyName("num_top_feature_importance_values")]
		public int? NumTopFeatureImportanceValues { get; set; }

		[JsonInclude]
		[JsonPropertyName("prediction_field_type")]
		public string? PredictionFieldType { get; set; }

		[JsonInclude]
		[JsonPropertyName("results_field")]
		public string? ResultsField { get; set; }

		[JsonInclude]
		[JsonPropertyName("top_classes_results_field")]
		public string? TopClassesResultsField { get; set; }
	}

	[ConvertAs(typeof(CompositeAggregation))]
	public partial interface ICompositeAggregation
	{
		int? Size { get; set; }

		IEnumerable<Dictionary<string, Elastic.Clients.Elasticsearch.Aggregations.ICompositeAggregationSource>>? Sources { get; set; }
	}

	public partial class CompositeAggregationDescriptor : DescriptorBase<CompositeAggregationDescriptor, ICompositeAggregation>, ICompositeAggregation
	{
		int? ICompositeAggregation.Size { get; set; }

		IEnumerable<Dictionary<string, Elastic.Clients.Elasticsearch.Aggregations.ICompositeAggregationSource>>? ICompositeAggregation.Sources { get; set; }
	}

	public partial class CompositeAggregation : Aggregations.BucketAggregationBase, ICompositeAggregation
	{
		[JsonInclude]
		[JsonPropertyName("size")]
		public int? Size { get; set; }

		[JsonInclude]
		[JsonPropertyName("sources")]
		public IEnumerable<Dictionary<string, Elastic.Clients.Elasticsearch.Aggregations.ICompositeAggregationSource>>? Sources { get; set; }
	}

	[ConvertAs(typeof(CompositeAggregationSource))]
	public partial interface ICompositeAggregationSource
	{
		Elastic.Clients.Elasticsearch.Aggregations.IDateHistogramAggregation? DateHistogram { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.IGeoTileGridAggregation? GeotileGrid { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.IHistogramAggregation? Histogram { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.ITermsAggregation? Terms { get; set; }
	}

	public partial class CompositeAggregationSourceDescriptor : DescriptorBase<CompositeAggregationSourceDescriptor, ICompositeAggregationSource>, ICompositeAggregationSource
	{
		Elastic.Clients.Elasticsearch.Aggregations.ITermsAggregation? ICompositeAggregationSource.Terms { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.IHistogramAggregation? ICompositeAggregationSource.Histogram { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.IDateHistogramAggregation? ICompositeAggregationSource.DateHistogram { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.IGeoTileGridAggregation? ICompositeAggregationSource.GeotileGrid { get; set; }
	}

	public partial class CompositeAggregationSource : ICompositeAggregationSource
	{
		[JsonInclude]
		[JsonPropertyName("date_histogram")]
		public Elastic.Clients.Elasticsearch.Aggregations.IDateHistogramAggregation? DateHistogram { get; set; }

		[JsonInclude]
		[JsonPropertyName("geotile_grid")]
		public Elastic.Clients.Elasticsearch.Aggregations.IGeoTileGridAggregation? GeotileGrid { get; set; }

		[JsonInclude]
		[JsonPropertyName("histogram")]
		public Elastic.Clients.Elasticsearch.Aggregations.IHistogramAggregation? Histogram { get; set; }

		[JsonInclude]
		[JsonPropertyName("terms")]
		public Elastic.Clients.Elasticsearch.Aggregations.ITermsAggregation? Terms { get; set; }
	}

	public partial class CompositeBucket
	{
	}

	public partial class CompositeBucketAggregate<TBucket> : Aggregations.MultiBucketAggregate<TBucket>
	{
		[JsonInclude]
		[JsonPropertyName("after_key")]
		public Dictionary<string, object> AfterKey
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	[ConvertAs(typeof(CumulativeCardinalityAggregation))]
	public partial interface ICumulativeCardinalityAggregation
	{
	}

	public partial class CumulativeCardinalityAggregationDescriptor : DescriptorBase<CumulativeCardinalityAggregationDescriptor, ICumulativeCardinalityAggregation>, ICumulativeCardinalityAggregation
	{
	}

	public partial class CumulativeCardinalityAggregation : Aggregations.PipelineAggregationBase, ICumulativeCardinalityAggregation
	{
	}

	[ConvertAs(typeof(CumulativeSumAggregation))]
	public partial interface ICumulativeSumAggregation
	{
	}

	public partial class CumulativeSumAggregationDescriptor : DescriptorBase<CumulativeSumAggregationDescriptor, ICumulativeSumAggregation>, ICumulativeSumAggregation
	{
	}

	public partial class CumulativeSumAggregation : Aggregations.PipelineAggregationBase, ICumulativeSumAggregation
	{
	}

	[ConvertAs(typeof(DateHistogramAggregation))]
	public partial interface IDateHistogramAggregation
	{
		Union<Elastic.Clients.Elasticsearch.Aggregations.DateInterval, Elastic.Clients.Elasticsearch.Time>? CalendarInterval { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.IExtendedBounds<Union<Elastic.Clients.Elasticsearch.DateMath, long>>? ExtendedBounds { get; set; }

		Elastic.Clients.Elasticsearch.Field? Field { get; set; }

		Union<Elastic.Clients.Elasticsearch.Aggregations.DateInterval, Elastic.Clients.Elasticsearch.Time>? FixedInterval { get; set; }

		string? Format { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.IExtendedBounds<Union<Elastic.Clients.Elasticsearch.DateMath, long>>? HardBounds { get; set; }

		Union<Elastic.Clients.Elasticsearch.Aggregations.DateInterval, Elastic.Clients.Elasticsearch.Time>? Interval { get; set; }

		bool? Keyed { get; set; }

		int? MinDocCount { get; set; }

		Elastic.Clients.Elasticsearch.DateString? Missing { get; set; }

		Elastic.Clients.Elasticsearch.Time? Offset { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.IHistogramOrder? Order { get; set; }

		Dictionary<string, object>? Params { get; set; }

		Elastic.Clients.Elasticsearch.Script? Script { get; set; }

		string? TimeZone { get; set; }
	}

	public partial class DateHistogramAggregationDescriptor : DescriptorBase<DateHistogramAggregationDescriptor, IDateHistogramAggregation>, IDateHistogramAggregation
	{
		Union<Elastic.Clients.Elasticsearch.Aggregations.DateInterval, Elastic.Clients.Elasticsearch.Time>? IDateHistogramAggregation.CalendarInterval { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.IExtendedBounds<Union<Elastic.Clients.Elasticsearch.DateMath, long>>? IDateHistogramAggregation.ExtendedBounds { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.IExtendedBounds<Union<Elastic.Clients.Elasticsearch.DateMath, long>>? IDateHistogramAggregation.HardBounds { get; set; }

		Elastic.Clients.Elasticsearch.Field? IDateHistogramAggregation.Field { get; set; }

		Union<Elastic.Clients.Elasticsearch.Aggregations.DateInterval, Elastic.Clients.Elasticsearch.Time>? IDateHistogramAggregation.FixedInterval { get; set; }

		string? IDateHistogramAggregation.Format { get; set; }

		Union<Elastic.Clients.Elasticsearch.Aggregations.DateInterval, Elastic.Clients.Elasticsearch.Time>? IDateHistogramAggregation.Interval { get; set; }

		int? IDateHistogramAggregation.MinDocCount { get; set; }

		Elastic.Clients.Elasticsearch.DateString? IDateHistogramAggregation.Missing { get; set; }

		Elastic.Clients.Elasticsearch.Time? IDateHistogramAggregation.Offset { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.IHistogramOrder? IDateHistogramAggregation.Order { get; set; }

		Dictionary<string, object>? IDateHistogramAggregation.Params { get; set; }

		Elastic.Clients.Elasticsearch.Script? IDateHistogramAggregation.Script { get; set; }

		string? IDateHistogramAggregation.TimeZone { get; set; }

		bool? IDateHistogramAggregation.Keyed { get; set; }
	}

	public partial class DateHistogramAggregation : Aggregations.BucketAggregationBase, IDateHistogramAggregation
	{
		[JsonInclude]
		[JsonPropertyName("calendar_interval")]
		public Union<Elastic.Clients.Elasticsearch.Aggregations.DateInterval, Elastic.Clients.Elasticsearch.Time>? CalendarInterval { get; set; }

		[JsonInclude]
		[JsonPropertyName("extended_bounds")]
		public Elastic.Clients.Elasticsearch.Aggregations.IExtendedBounds<Union<Elastic.Clients.Elasticsearch.DateMath, long>>? ExtendedBounds { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public Elastic.Clients.Elasticsearch.Field? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("fixed_interval")]
		public Union<Elastic.Clients.Elasticsearch.Aggregations.DateInterval, Elastic.Clients.Elasticsearch.Time>? FixedInterval { get; set; }

		[JsonInclude]
		[JsonPropertyName("format")]
		public string? Format { get; set; }

		[JsonInclude]
		[JsonPropertyName("hard_bounds")]
		public Elastic.Clients.Elasticsearch.Aggregations.IExtendedBounds<Union<Elastic.Clients.Elasticsearch.DateMath, long>>? HardBounds { get; set; }

		[JsonInclude]
		[JsonPropertyName("interval")]
		public Union<Elastic.Clients.Elasticsearch.Aggregations.DateInterval, Elastic.Clients.Elasticsearch.Time>? Interval { get; set; }

		[JsonInclude]
		[JsonPropertyName("keyed")]
		public bool? Keyed { get; set; }

		[JsonInclude]
		[JsonPropertyName("min_doc_count")]
		public int? MinDocCount { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing")]
		public Elastic.Clients.Elasticsearch.DateString? Missing { get; set; }

		[JsonInclude]
		[JsonPropertyName("offset")]
		public Elastic.Clients.Elasticsearch.Time? Offset { get; set; }

		[JsonInclude]
		[JsonPropertyName("order")]
		public Elastic.Clients.Elasticsearch.Aggregations.IHistogramOrder? Order { get; set; }

		[JsonInclude]
		[JsonPropertyName("params")]
		public Dictionary<string, object>? Params { get; set; }

		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script? Script { get; set; }

		[JsonInclude]
		[JsonPropertyName("time_zone")]
		public string? TimeZone { get; set; }
	}

	public partial class DateHistogramBucket
	{
	}

	[ConvertAs(typeof(DateRangeAggregation))]
	public partial interface IDateRangeAggregation
	{
		Elastic.Clients.Elasticsearch.Field? Field { get; set; }

		string? Format { get; set; }

		bool? Keyed { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.Missing? Missing { get; set; }

		IEnumerable<Elastic.Clients.Elasticsearch.Aggregations.IDateRangeExpression>? Ranges { get; set; }

		string? TimeZone { get; set; }
	}

	public partial class DateRangeAggregationDescriptor : DescriptorBase<DateRangeAggregationDescriptor, IDateRangeAggregation>, IDateRangeAggregation
	{
		Elastic.Clients.Elasticsearch.Field? IDateRangeAggregation.Field { get; set; }

		string? IDateRangeAggregation.Format { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.Missing? IDateRangeAggregation.Missing { get; set; }

		IEnumerable<Elastic.Clients.Elasticsearch.Aggregations.IDateRangeExpression>? IDateRangeAggregation.Ranges { get; set; }

		string? IDateRangeAggregation.TimeZone { get; set; }

		bool? IDateRangeAggregation.Keyed { get; set; }
	}

	public partial class DateRangeAggregation : Aggregations.BucketAggregationBase, IDateRangeAggregation
	{
		[JsonInclude]
		[JsonPropertyName("field")]
		public Elastic.Clients.Elasticsearch.Field? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("format")]
		public string? Format { get; set; }

		[JsonInclude]
		[JsonPropertyName("keyed")]
		public bool? Keyed { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing")]
		public Elastic.Clients.Elasticsearch.Aggregations.Missing? Missing { get; set; }

		[JsonInclude]
		[JsonPropertyName("ranges")]
		public IEnumerable<Elastic.Clients.Elasticsearch.Aggregations.IDateRangeExpression>? Ranges { get; set; }

		[JsonInclude]
		[JsonPropertyName("time_zone")]
		public string? TimeZone { get; set; }
	}

	[ConvertAs(typeof(DateRangeExpression))]
	public partial interface IDateRangeExpression
	{
		long? DocCount { get; set; }

		Union<Elastic.Clients.Elasticsearch.DateMath, float>? From { get; set; }

		string? FromAsString { get; set; }

		string? Key { get; set; }

		Union<Elastic.Clients.Elasticsearch.DateMath, float>? To { get; set; }

		string? ToAsString { get; set; }
	}

	public partial class DateRangeExpressionDescriptor : DescriptorBase<DateRangeExpressionDescriptor, IDateRangeExpression>, IDateRangeExpression
	{
		Union<Elastic.Clients.Elasticsearch.DateMath, float>? IDateRangeExpression.From { get; set; }

		string? IDateRangeExpression.FromAsString { get; set; }

		string? IDateRangeExpression.ToAsString { get; set; }

		string? IDateRangeExpression.Key { get; set; }

		Union<Elastic.Clients.Elasticsearch.DateMath, float>? IDateRangeExpression.To { get; set; }

		long? IDateRangeExpression.DocCount { get; set; }
	}

	public partial class DateRangeExpression : IDateRangeExpression
	{
		[JsonInclude]
		[JsonPropertyName("doc_count")]
		public long? DocCount { get; set; }

		[JsonInclude]
		[JsonPropertyName("from")]
		public Union<Elastic.Clients.Elasticsearch.DateMath, float>? From { get; set; }

		[JsonInclude]
		[JsonPropertyName("from_as_string")]
		public string? FromAsString { get; set; }

		[JsonInclude]
		[JsonPropertyName("key")]
		public string? Key { get; set; }

		[JsonInclude]
		[JsonPropertyName("to")]
		public Union<Elastic.Clients.Elasticsearch.DateMath, float>? To { get; set; }

		[JsonInclude]
		[JsonPropertyName("to_as_string")]
		public string? ToAsString { get; set; }
	}

	[ConvertAs(typeof(DerivativeAggregation))]
	public partial interface IDerivativeAggregation
	{
	}

	public partial class DerivativeAggregationDescriptor : DescriptorBase<DerivativeAggregationDescriptor, IDerivativeAggregation>, IDerivativeAggregation
	{
	}

	public partial class DerivativeAggregation : Aggregations.PipelineAggregationBase, IDerivativeAggregation
	{
	}

	[ConvertAs(typeof(DiversifiedSamplerAggregation))]
	public partial interface IDiversifiedSamplerAggregation
	{
		Elastic.Clients.Elasticsearch.Aggregations.SamplerAggregationExecutionHint? ExecutionHint { get; set; }

		Elastic.Clients.Elasticsearch.Field? Field { get; set; }

		int? MaxDocsPerValue { get; set; }

		Elastic.Clients.Elasticsearch.Script? Script { get; set; }

		int? ShardSize { get; set; }
	}

	public partial class DiversifiedSamplerAggregationDescriptor : DescriptorBase<DiversifiedSamplerAggregationDescriptor, IDiversifiedSamplerAggregation>, IDiversifiedSamplerAggregation
	{
		Elastic.Clients.Elasticsearch.Aggregations.SamplerAggregationExecutionHint? IDiversifiedSamplerAggregation.ExecutionHint { get; set; }

		int? IDiversifiedSamplerAggregation.MaxDocsPerValue { get; set; }

		Elastic.Clients.Elasticsearch.Script? IDiversifiedSamplerAggregation.Script { get; set; }

		int? IDiversifiedSamplerAggregation.ShardSize { get; set; }

		Elastic.Clients.Elasticsearch.Field? IDiversifiedSamplerAggregation.Field { get; set; }
	}

	public partial class DiversifiedSamplerAggregation : Aggregations.BucketAggregationBase, IDiversifiedSamplerAggregation
	{
		[JsonInclude]
		[JsonPropertyName("execution_hint")]
		public Elastic.Clients.Elasticsearch.Aggregations.SamplerAggregationExecutionHint? ExecutionHint { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public Elastic.Clients.Elasticsearch.Field? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_docs_per_value")]
		public int? MaxDocsPerValue { get; set; }

		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script? Script { get; set; }

		[JsonInclude]
		[JsonPropertyName("shard_size")]
		public int? ShardSize { get; set; }
	}

	public partial class EwmaModelSettings
	{
		[JsonInclude]
		[JsonPropertyName("alpha")]
		public float? Alpha
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	[ConvertAs(typeof(ExtendedBounds<>))]
	public partial interface IExtendedBounds<T>
	{
		T Max { get; set; }

		T Min { get; set; }
	}

	public partial class ExtendedBoundsDescriptor<T> : DescriptorBase<ExtendedBoundsDescriptor<T>, IExtendedBounds<T>>, IExtendedBounds<T>
	{
		T IExtendedBounds<T>.Max { get; set; }

		T IExtendedBounds<T>.Min { get; set; }
	}

	public partial class ExtendedBounds<T> : IExtendedBounds<T>
	{
		[JsonInclude]
		[JsonPropertyName("max")]
		public T Max { get; set; }

		[JsonInclude]
		[JsonPropertyName("min")]
		public T Min { get; set; }
	}

	public partial class ExtendedStatsAggregate : Aggregations.StatsAggregate
	{
		[JsonInclude]
		[JsonPropertyName("std_deviation")]
		public double? StdDeviation
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("std_deviation_bounds")]
		public Elastic.Clients.Elasticsearch.Aggregations.StandardDeviationBounds StdDeviationBounds
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("std_deviation_population")]
		public double? StdDeviationPopulation
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("std_deviation_sampling")]
		public double? StdDeviationSampling
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("sum_of_squares")]
		public double? SumOfSquares
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("variance")]
		public double? Variance
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("variance_population")]
		public double? VariancePopulation
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("variance_sampling")]
		public double? VarianceSampling
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	[ConvertAs(typeof(ExtendedStatsAggregation))]
	public partial interface IExtendedStatsAggregation
	{
		double? Sigma { get; set; }
	}

	public partial class ExtendedStatsAggregationDescriptor : DescriptorBase<ExtendedStatsAggregationDescriptor, IExtendedStatsAggregation>, IExtendedStatsAggregation
	{
		double? IExtendedStatsAggregation.Sigma { get; set; }
	}

	public partial class ExtendedStatsAggregation : Aggregations.FormatMetricAggregationBase, IExtendedStatsAggregation
	{
		[JsonInclude]
		[JsonPropertyName("sigma")]
		public double? Sigma { get; set; }
	}

	[ConvertAs(typeof(ExtendedStatsBucketAggregation))]
	public partial interface IExtendedStatsBucketAggregation
	{
		double? Sigma { get; set; }
	}

	public partial class ExtendedStatsBucketAggregationDescriptor : DescriptorBase<ExtendedStatsBucketAggregationDescriptor, IExtendedStatsBucketAggregation>, IExtendedStatsBucketAggregation
	{
		double? IExtendedStatsBucketAggregation.Sigma { get; set; }
	}

	public partial class ExtendedStatsBucketAggregation : Aggregations.PipelineAggregationBase, IExtendedStatsBucketAggregation
	{
		[JsonInclude]
		[JsonPropertyName("sigma")]
		public double? Sigma { get; set; }
	}

	public partial class FiltersAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("buckets")]
		public Union<IReadOnlyCollection<Elastic.Clients.Elasticsearch.Aggregations.FiltersBucketItem>, Dictionary<string, Elastic.Clients.Elasticsearch.Aggregations.FiltersBucketItem>> Buckets
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	[ConvertAs(typeof(FiltersAggregation))]
	public partial interface IFiltersAggregation
	{
		Union<Dictionary<string, Elastic.Clients.Elasticsearch.QueryDsl.IQueryContainer>, IEnumerable<Elastic.Clients.Elasticsearch.QueryDsl.IQueryContainer>>? Filters { get; set; }

		bool? Keyed { get; set; }

		bool? OtherBucket { get; set; }

		string? OtherBucketKey { get; set; }
	}

	public partial class FiltersAggregationDescriptor : DescriptorBase<FiltersAggregationDescriptor, IFiltersAggregation>, IFiltersAggregation
	{
		Union<Dictionary<string, Elastic.Clients.Elasticsearch.QueryDsl.IQueryContainer>, IEnumerable<Elastic.Clients.Elasticsearch.QueryDsl.IQueryContainer>>? IFiltersAggregation.Filters { get; set; }

		bool? IFiltersAggregation.OtherBucket { get; set; }

		string? IFiltersAggregation.OtherBucketKey { get; set; }

		bool? IFiltersAggregation.Keyed { get; set; }
	}

	public partial class FiltersAggregation : Aggregations.BucketAggregationBase, IFiltersAggregation
	{
		[JsonInclude]
		[JsonPropertyName("filters")]
		public Union<Dictionary<string, Elastic.Clients.Elasticsearch.QueryDsl.IQueryContainer>, IEnumerable<Elastic.Clients.Elasticsearch.QueryDsl.IQueryContainer>>? Filters { get; set; }

		[JsonInclude]
		[JsonPropertyName("keyed")]
		public bool? Keyed { get; set; }

		[JsonInclude]
		[JsonPropertyName("other_bucket")]
		public bool? OtherBucket { get; set; }

		[JsonInclude]
		[JsonPropertyName("other_bucket_key")]
		public string? OtherBucketKey { get; set; }
	}

	public partial class FiltersBucketItem
	{
		[JsonInclude]
		[JsonPropertyName("doc_count")]
		public long DocCount
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	[ConvertAs(typeof(FormatMetricAggregationBase))]
	public partial interface IFormatMetricAggregationBase
	{
		string? Format { get; set; }
	}

	public partial class FormatMetricAggregationBaseDescriptor : DescriptorBase<FormatMetricAggregationBaseDescriptor, IFormatMetricAggregationBase>, IFormatMetricAggregationBase
	{
		string? IFormatMetricAggregationBase.Format { get; set; }
	}

	public abstract partial class FormatMetricAggregationBase : Aggregations.MetricAggregationBase, IFormatMetricAggregationBase
	{
		[JsonInclude]
		[JsonPropertyName("format")]
		public string? Format { get; set; }
	}

	[ConvertAs(typeof(FormattableMetricAggregation))]
	public partial interface IFormattableMetricAggregation
	{
		string? Format { get; set; }
	}

	public partial class FormattableMetricAggregationDescriptor : DescriptorBase<FormattableMetricAggregationDescriptor, IFormattableMetricAggregation>, IFormattableMetricAggregation
	{
		string? IFormattableMetricAggregation.Format { get; set; }
	}

	public partial class FormattableMetricAggregation : Aggregations.MetricAggregationBase, IFormattableMetricAggregation
	{
		[JsonInclude]
		[JsonPropertyName("format")]
		public string? Format { get; set; }
	}

	[ConvertAs(typeof(GeoBounds))]
	public partial interface IGeoBounds
	{
		Elastic.Clients.Elasticsearch.ILatLon BottomRight { get; set; }

		Elastic.Clients.Elasticsearch.ILatLon TopLeft { get; set; }
	}

	public partial class GeoBoundsDescriptor : DescriptorBase<GeoBoundsDescriptor, IGeoBounds>, IGeoBounds
	{
		Elastic.Clients.Elasticsearch.ILatLon IGeoBounds.BottomRight { get; set; }

		Elastic.Clients.Elasticsearch.ILatLon IGeoBounds.TopLeft { get; set; }
	}

	public partial class GeoBounds : IGeoBounds
	{
		[JsonInclude]
		[JsonPropertyName("bottom_right")]
		public Elastic.Clients.Elasticsearch.ILatLon BottomRight { get; set; }

		[JsonInclude]
		[JsonPropertyName("top_left")]
		public Elastic.Clients.Elasticsearch.ILatLon TopLeft { get; set; }
	}

	public partial class GeoBoundsAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("bounds")]
		public Elastic.Clients.Elasticsearch.Aggregations.IGeoBounds Bounds
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	[ConvertAs(typeof(GeoBoundsAggregation))]
	public partial interface IGeoBoundsAggregation
	{
		bool? WrapLongitude { get; set; }
	}

	public partial class GeoBoundsAggregationDescriptor : DescriptorBase<GeoBoundsAggregationDescriptor, IGeoBoundsAggregation>, IGeoBoundsAggregation
	{
		bool? IGeoBoundsAggregation.WrapLongitude { get; set; }
	}

	public partial class GeoBoundsAggregation : Aggregations.MetricAggregationBase, IGeoBoundsAggregation
	{
		[JsonInclude]
		[JsonPropertyName("wrap_longitude")]
		public bool? WrapLongitude { get; set; }
	}

	public partial class GeoCentroidAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("count")]
		public long Count
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("location")]
		public Elastic.Clients.Elasticsearch.QueryDsl.GeoLocation Location
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	[ConvertAs(typeof(GeoCentroidAggregation))]
	public partial interface IGeoCentroidAggregation
	{
		long? Count { get; set; }

		Elastic.Clients.Elasticsearch.QueryDsl.GeoLocation? Location { get; set; }
	}

	public partial class GeoCentroidAggregationDescriptor : DescriptorBase<GeoCentroidAggregationDescriptor, IGeoCentroidAggregation>, IGeoCentroidAggregation
	{
		long? IGeoCentroidAggregation.Count { get; set; }

		Elastic.Clients.Elasticsearch.QueryDsl.GeoLocation? IGeoCentroidAggregation.Location { get; set; }
	}

	public partial class GeoCentroidAggregation : Aggregations.MetricAggregationBase, IGeoCentroidAggregation
	{
		[JsonInclude]
		[JsonPropertyName("count")]
		public long? Count { get; set; }

		[JsonInclude]
		[JsonPropertyName("location")]
		public Elastic.Clients.Elasticsearch.QueryDsl.GeoLocation? Location { get; set; }
	}

	[ConvertAs(typeof(GeoDistanceAggregation))]
	public partial interface IGeoDistanceAggregation
	{
		Elastic.Clients.Elasticsearch.GeoDistanceType? DistanceType { get; set; }

		Elastic.Clients.Elasticsearch.Field? Field { get; set; }

		Union<Elastic.Clients.Elasticsearch.QueryDsl.GeoLocation, string>? Origin { get; set; }

		IEnumerable<Elastic.Clients.Elasticsearch.Aggregations.IAggregationRange>? Ranges { get; set; }

		Elastic.Clients.Elasticsearch.DistanceUnit? Unit { get; set; }
	}

	public partial class GeoDistanceAggregationDescriptor : DescriptorBase<GeoDistanceAggregationDescriptor, IGeoDistanceAggregation>, IGeoDistanceAggregation
	{
		Elastic.Clients.Elasticsearch.GeoDistanceType? IGeoDistanceAggregation.DistanceType { get; set; }

		Elastic.Clients.Elasticsearch.Field? IGeoDistanceAggregation.Field { get; set; }

		Union<Elastic.Clients.Elasticsearch.QueryDsl.GeoLocation, string>? IGeoDistanceAggregation.Origin { get; set; }

		IEnumerable<Elastic.Clients.Elasticsearch.Aggregations.IAggregationRange>? IGeoDistanceAggregation.Ranges { get; set; }

		Elastic.Clients.Elasticsearch.DistanceUnit? IGeoDistanceAggregation.Unit { get; set; }
	}

	public partial class GeoDistanceAggregation : Aggregations.BucketAggregationBase, IGeoDistanceAggregation
	{
		[JsonInclude]
		[JsonPropertyName("distance_type")]
		public Elastic.Clients.Elasticsearch.GeoDistanceType? DistanceType { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public Elastic.Clients.Elasticsearch.Field? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("origin")]
		public Union<Elastic.Clients.Elasticsearch.QueryDsl.GeoLocation, string>? Origin { get; set; }

		[JsonInclude]
		[JsonPropertyName("ranges")]
		public IEnumerable<Elastic.Clients.Elasticsearch.Aggregations.IAggregationRange>? Ranges { get; set; }

		[JsonInclude]
		[JsonPropertyName("unit")]
		public Elastic.Clients.Elasticsearch.DistanceUnit? Unit { get; set; }
	}

	[ConvertAs(typeof(GeoHashGridAggregation))]
	public partial interface IGeoHashGridAggregation
	{
		Elastic.Clients.Elasticsearch.QueryDsl.IBoundingBox? Bounds { get; set; }

		Elastic.Clients.Elasticsearch.Field? Field { get; set; }

		Elastic.Clients.Elasticsearch.GeoHashPrecision? Precision { get; set; }

		int? ShardSize { get; set; }

		int? Size { get; set; }
	}

	public partial class GeoHashGridAggregationDescriptor : DescriptorBase<GeoHashGridAggregationDescriptor, IGeoHashGridAggregation>, IGeoHashGridAggregation
	{
		Elastic.Clients.Elasticsearch.QueryDsl.IBoundingBox? IGeoHashGridAggregation.Bounds { get; set; }

		Elastic.Clients.Elasticsearch.Field? IGeoHashGridAggregation.Field { get; set; }

		Elastic.Clients.Elasticsearch.GeoHashPrecision? IGeoHashGridAggregation.Precision { get; set; }

		int? IGeoHashGridAggregation.ShardSize { get; set; }

		int? IGeoHashGridAggregation.Size { get; set; }
	}

	public partial class GeoHashGridAggregation : Aggregations.BucketAggregationBase, IGeoHashGridAggregation
	{
		[JsonInclude]
		[JsonPropertyName("bounds")]
		public Elastic.Clients.Elasticsearch.QueryDsl.IBoundingBox? Bounds { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public Elastic.Clients.Elasticsearch.Field? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("precision")]
		public Elastic.Clients.Elasticsearch.GeoHashPrecision? Precision { get; set; }

		[JsonInclude]
		[JsonPropertyName("shard_size")]
		public int? ShardSize { get; set; }

		[JsonInclude]
		[JsonPropertyName("size")]
		public int? Size { get; set; }
	}

	public partial class GeoLineAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("geometry")]
		public Elastic.Clients.Elasticsearch.Aggregations.LineStringGeoShape Geometry
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("properties")]
		public Elastic.Clients.Elasticsearch.Aggregations.GeoLineProperties Properties
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	[ConvertAs(typeof(GeoLineAggregation))]
	public partial interface IGeoLineAggregation
	{
		bool? IncludeSort { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.IGeoLinePoint Point { get; set; }

		int? Size { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.IGeoLineSort Sort { get; set; }

		Elastic.Clients.Elasticsearch.Global.Search.SortOrder? SortOrder { get; set; }
	}

	public partial class GeoLineAggregationDescriptor : DescriptorBase<GeoLineAggregationDescriptor, IGeoLineAggregation>, IGeoLineAggregation
	{
		Elastic.Clients.Elasticsearch.Aggregations.IGeoLinePoint IGeoLineAggregation.Point { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.IGeoLineSort IGeoLineAggregation.Sort { get; set; }

		bool? IGeoLineAggregation.IncludeSort { get; set; }

		Elastic.Clients.Elasticsearch.Global.Search.SortOrder? IGeoLineAggregation.SortOrder { get; set; }

		int? IGeoLineAggregation.Size { get; set; }
	}

	public partial class GeoLineAggregation : IGeoLineAggregation
	{
		[JsonInclude]
		[JsonPropertyName("include_sort")]
		public bool? IncludeSort { get; set; }

		[JsonInclude]
		[JsonPropertyName("point")]
		public Elastic.Clients.Elasticsearch.Aggregations.IGeoLinePoint Point { get; set; }

		[JsonInclude]
		[JsonPropertyName("size")]
		public int? Size { get; set; }

		[JsonInclude]
		[JsonPropertyName("sort")]
		public Elastic.Clients.Elasticsearch.Aggregations.IGeoLineSort Sort { get; set; }

		[JsonInclude]
		[JsonPropertyName("sort_order")]
		public Elastic.Clients.Elasticsearch.Global.Search.SortOrder? SortOrder { get; set; }
	}

	[ConvertAs(typeof(GeoLinePoint))]
	public partial interface IGeoLinePoint
	{
		Elastic.Clients.Elasticsearch.Field Field { get; set; }
	}

	public partial class GeoLinePointDescriptor : DescriptorBase<GeoLinePointDescriptor, IGeoLinePoint>, IGeoLinePoint
	{
		Elastic.Clients.Elasticsearch.Field IGeoLinePoint.Field { get; set; }
	}

	public partial class GeoLinePoint : IGeoLinePoint
	{
		[JsonInclude]
		[JsonPropertyName("field")]
		public Elastic.Clients.Elasticsearch.Field Field { get; set; }
	}

	public partial class GeoLineProperties
	{
		[JsonInclude]
		[JsonPropertyName("complete")]
		public bool Complete
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("sort_values")]
		public IReadOnlyCollection<double> SortValues
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	[ConvertAs(typeof(GeoLineSort))]
	public partial interface IGeoLineSort
	{
		Elastic.Clients.Elasticsearch.Field Field { get; set; }
	}

	public partial class GeoLineSortDescriptor : DescriptorBase<GeoLineSortDescriptor, IGeoLineSort>, IGeoLineSort
	{
		Elastic.Clients.Elasticsearch.Field IGeoLineSort.Field { get; set; }
	}

	public partial class GeoLineSort : IGeoLineSort
	{
		[JsonInclude]
		[JsonPropertyName("field")]
		public Elastic.Clients.Elasticsearch.Field Field { get; set; }
	}

	[ConvertAs(typeof(GeoTileGridAggregation))]
	public partial interface IGeoTileGridAggregation
	{
		Elastic.Clients.Elasticsearch.Aggregations.IGeoBounds? Bounds { get; set; }

		Elastic.Clients.Elasticsearch.Field? Field { get; set; }

		Elastic.Clients.Elasticsearch.GeoTilePrecision? Precision { get; set; }

		int? ShardSize { get; set; }

		int? Size { get; set; }
	}

	public partial class GeoTileGridAggregationDescriptor : DescriptorBase<GeoTileGridAggregationDescriptor, IGeoTileGridAggregation>, IGeoTileGridAggregation
	{
		Elastic.Clients.Elasticsearch.Field? IGeoTileGridAggregation.Field { get; set; }

		Elastic.Clients.Elasticsearch.GeoTilePrecision? IGeoTileGridAggregation.Precision { get; set; }

		int? IGeoTileGridAggregation.ShardSize { get; set; }

		int? IGeoTileGridAggregation.Size { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.IGeoBounds? IGeoTileGridAggregation.Bounds { get; set; }
	}

	public partial class GeoTileGridAggregation : Aggregations.BucketAggregationBase, IGeoTileGridAggregation
	{
		[JsonInclude]
		[JsonPropertyName("bounds")]
		public Elastic.Clients.Elasticsearch.Aggregations.IGeoBounds? Bounds { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public Elastic.Clients.Elasticsearch.Field? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("precision")]
		public Elastic.Clients.Elasticsearch.GeoTilePrecision? Precision { get; set; }

		[JsonInclude]
		[JsonPropertyName("shard_size")]
		public int? ShardSize { get; set; }

		[JsonInclude]
		[JsonPropertyName("size")]
		public int? Size { get; set; }
	}

	[ConvertAs(typeof(GlobalAggregation))]
	public partial interface IGlobalAggregation
	{
	}

	public partial class GlobalAggregationDescriptor : DescriptorBase<GlobalAggregationDescriptor, IGlobalAggregation>, IGlobalAggregation
	{
	}

	public partial class GlobalAggregation : Aggregations.BucketAggregationBase, IGlobalAggregation
	{
	}

	[ConvertAs(typeof(GoogleNormalizedDistanceHeuristic))]
	public partial interface IGoogleNormalizedDistanceHeuristic
	{
		bool BackgroundIsSuperset { get; set; }
	}

	public partial class GoogleNormalizedDistanceHeuristicDescriptor : DescriptorBase<GoogleNormalizedDistanceHeuristicDescriptor, IGoogleNormalizedDistanceHeuristic>, IGoogleNormalizedDistanceHeuristic
	{
		bool IGoogleNormalizedDistanceHeuristic.BackgroundIsSuperset { get; set; }
	}

	public partial class GoogleNormalizedDistanceHeuristic : IGoogleNormalizedDistanceHeuristic
	{
		[JsonInclude]
		[JsonPropertyName("background_is_superset")]
		public bool BackgroundIsSuperset { get; set; }
	}

	[ConvertAs(typeof(HdrMethod))]
	public partial interface IHdrMethod
	{
		int? NumberOfSignificantValueDigits { get; set; }
	}

	public partial class HdrMethodDescriptor : DescriptorBase<HdrMethodDescriptor, IHdrMethod>, IHdrMethod
	{
		int? IHdrMethod.NumberOfSignificantValueDigits { get; set; }
	}

	public partial class HdrMethod : IHdrMethod
	{
		[JsonInclude]
		[JsonPropertyName("number_of_significant_value_digits")]
		public int? NumberOfSignificantValueDigits { get; set; }
	}

	public partial class HdrPercentileItem
	{
		[JsonInclude]
		[JsonPropertyName("key")]
		public double Key
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("value")]
		public double Value
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	public partial class HdrPercentilesAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("values")]
		public IReadOnlyCollection<Elastic.Clients.Elasticsearch.Aggregations.HdrPercentileItem> Values
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	[ConvertAs(typeof(HistogramAggregation))]
	public partial interface IHistogramAggregation
	{
		Elastic.Clients.Elasticsearch.Aggregations.IExtendedBounds<double>? ExtendedBounds { get; set; }

		Elastic.Clients.Elasticsearch.Field? Field { get; set; }

		string? Format { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.IExtendedBounds<double>? HardBounds { get; set; }

		double? Interval { get; set; }

		bool? Keyed { get; set; }

		int? MinDocCount { get; set; }

		double? Missing { get; set; }

		double? Offset { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.IHistogramOrder? Order { get; set; }

		Elastic.Clients.Elasticsearch.Script? Script { get; set; }
	}

	public partial class HistogramAggregationDescriptor : DescriptorBase<HistogramAggregationDescriptor, IHistogramAggregation>, IHistogramAggregation
	{
		Elastic.Clients.Elasticsearch.Aggregations.IExtendedBounds<double>? IHistogramAggregation.ExtendedBounds { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.IExtendedBounds<double>? IHistogramAggregation.HardBounds { get; set; }

		Elastic.Clients.Elasticsearch.Field? IHistogramAggregation.Field { get; set; }

		double? IHistogramAggregation.Interval { get; set; }

		int? IHistogramAggregation.MinDocCount { get; set; }

		double? IHistogramAggregation.Missing { get; set; }

		double? IHistogramAggregation.Offset { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.IHistogramOrder? IHistogramAggregation.Order { get; set; }

		Elastic.Clients.Elasticsearch.Script? IHistogramAggregation.Script { get; set; }

		string? IHistogramAggregation.Format { get; set; }

		bool? IHistogramAggregation.Keyed { get; set; }
	}

	public partial class HistogramAggregation : Aggregations.BucketAggregationBase, IHistogramAggregation
	{
		[JsonInclude]
		[JsonPropertyName("extended_bounds")]
		public Elastic.Clients.Elasticsearch.Aggregations.IExtendedBounds<double>? ExtendedBounds { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public Elastic.Clients.Elasticsearch.Field? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("format")]
		public string? Format { get; set; }

		[JsonInclude]
		[JsonPropertyName("hard_bounds")]
		public Elastic.Clients.Elasticsearch.Aggregations.IExtendedBounds<double>? HardBounds { get; set; }

		[JsonInclude]
		[JsonPropertyName("interval")]
		public double? Interval { get; set; }

		[JsonInclude]
		[JsonPropertyName("keyed")]
		public bool? Keyed { get; set; }

		[JsonInclude]
		[JsonPropertyName("min_doc_count")]
		public int? MinDocCount { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing")]
		public double? Missing { get; set; }

		[JsonInclude]
		[JsonPropertyName("offset")]
		public double? Offset { get; set; }

		[JsonInclude]
		[JsonPropertyName("order")]
		public Elastic.Clients.Elasticsearch.Aggregations.IHistogramOrder? Order { get; set; }

		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script? Script { get; set; }
	}

	[ConvertAs(typeof(HistogramOrder))]
	public partial interface IHistogramOrder
	{
		Elastic.Clients.Elasticsearch.Global.Search.SortOrder? Count { get; set; }

		Elastic.Clients.Elasticsearch.Global.Search.SortOrder? Key { get; set; }
	}

	public partial class HistogramOrderDescriptor : DescriptorBase<HistogramOrderDescriptor, IHistogramOrder>, IHistogramOrder
	{
		Elastic.Clients.Elasticsearch.Global.Search.SortOrder? IHistogramOrder.Count { get; set; }

		Elastic.Clients.Elasticsearch.Global.Search.SortOrder? IHistogramOrder.Key { get; set; }
	}

	public partial class HistogramOrder : IHistogramOrder
	{
		[JsonInclude]
		[JsonPropertyName("_count")]
		public Elastic.Clients.Elasticsearch.Global.Search.SortOrder? Count { get; set; }

		[JsonInclude]
		[JsonPropertyName("_key")]
		public Elastic.Clients.Elasticsearch.Global.Search.SortOrder? Key { get; set; }
	}

	public partial class HoltLinearModelSettings
	{
		[JsonInclude]
		[JsonPropertyName("alpha")]
		public float? Alpha
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("beta")]
		public float? Beta
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	public partial class HoltWintersModelSettings
	{
		[JsonInclude]
		[JsonPropertyName("alpha")]
		public float? Alpha
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("beta")]
		public float? Beta
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("gamma")]
		public float? Gamma
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("pad")]
		public bool? Pad
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("period")]
		public int? Period
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public Elastic.Clients.Elasticsearch.Aggregations.HoltWintersType? Type
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	[ConvertAs(typeof(InferenceAggregation))]
	public partial interface IInferenceAggregation
	{
		Elastic.Clients.Elasticsearch.Aggregations.IInferenceConfigContainer? InferenceConfig { get; set; }

		Elastic.Clients.Elasticsearch.Name ModelId { get; set; }
	}

	public partial class InferenceAggregationDescriptor : DescriptorBase<InferenceAggregationDescriptor, IInferenceAggregation>, IInferenceAggregation
	{
		Elastic.Clients.Elasticsearch.Name IInferenceAggregation.ModelId { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.IInferenceConfigContainer? IInferenceAggregation.InferenceConfig { get; set; }
	}

	public partial class InferenceAggregation : Aggregations.PipelineAggregationBase, IInferenceAggregation
	{
		[JsonInclude]
		[JsonPropertyName("inference_config")]
		public Elastic.Clients.Elasticsearch.Aggregations.IInferenceConfigContainer? InferenceConfig { get; set; }

		[JsonInclude]
		[JsonPropertyName("model_id")]
		public Elastic.Clients.Elasticsearch.Name ModelId { get; set; }
	}

	[ConvertAs(typeof(InferenceConfigContainer))]
	public partial interface IInferenceConfigContainer
	{
		Elastic.Clients.Elasticsearch.Aggregations.IClassificationInferenceOptions? Classification { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.IRegressionInferenceOptions? Regression { get; set; }
	}

	public partial class InferenceConfigContainerDescriptor : DescriptorBase<InferenceConfigContainerDescriptor, IInferenceConfigContainer>, IInferenceConfigContainer
	{
		Elastic.Clients.Elasticsearch.Aggregations.IRegressionInferenceOptions? IInferenceConfigContainer.Regression { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.IClassificationInferenceOptions? IInferenceConfigContainer.Classification { get; set; }
	}

	public partial class InferenceConfigContainer : IInferenceConfigContainer
	{
		[JsonInclude]
		[JsonPropertyName("classification")]
		public Elastic.Clients.Elasticsearch.Aggregations.IClassificationInferenceOptions? Classification { get; set; }

		[JsonInclude]
		[JsonPropertyName("regression")]
		public Elastic.Clients.Elasticsearch.Aggregations.IRegressionInferenceOptions? Regression { get; set; }
	}

	[ConvertAs(typeof(IpRangeAggregation))]
	public partial interface IIpRangeAggregation
	{
		Elastic.Clients.Elasticsearch.Field? Field { get; set; }

		IEnumerable<Elastic.Clients.Elasticsearch.Aggregations.IIpRangeAggregationRange>? Ranges { get; set; }
	}

	public partial class IpRangeAggregationDescriptor : DescriptorBase<IpRangeAggregationDescriptor, IIpRangeAggregation>, IIpRangeAggregation
	{
		Elastic.Clients.Elasticsearch.Field? IIpRangeAggregation.Field { get; set; }

		IEnumerable<Elastic.Clients.Elasticsearch.Aggregations.IIpRangeAggregationRange>? IIpRangeAggregation.Ranges { get; set; }
	}

	public partial class IpRangeAggregation : Aggregations.BucketAggregationBase, IIpRangeAggregation
	{
		[JsonInclude]
		[JsonPropertyName("field")]
		public Elastic.Clients.Elasticsearch.Field? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("ranges")]
		public IEnumerable<Elastic.Clients.Elasticsearch.Aggregations.IIpRangeAggregationRange>? Ranges { get; set; }
	}

	[ConvertAs(typeof(IpRangeAggregationRange))]
	public partial interface IIpRangeAggregationRange
	{
		string? From { get; set; }

		string? Mask { get; set; }

		string? To { get; set; }
	}

	public partial class IpRangeAggregationRangeDescriptor : DescriptorBase<IpRangeAggregationRangeDescriptor, IIpRangeAggregationRange>, IIpRangeAggregationRange
	{
		string? IIpRangeAggregationRange.From { get; set; }

		string? IIpRangeAggregationRange.Mask { get; set; }

		string? IIpRangeAggregationRange.To { get; set; }
	}

	public partial class IpRangeAggregationRange : IIpRangeAggregationRange
	{
		[JsonInclude]
		[JsonPropertyName("from")]
		public string? From { get; set; }

		[JsonInclude]
		[JsonPropertyName("mask")]
		public string? Mask { get; set; }

		[JsonInclude]
		[JsonPropertyName("to")]
		public string? To { get; set; }
	}

	public partial class IpRangeBucket
	{
	}

	public partial class KeyedBucket<TKey>
	{
		[JsonInclude]
		[JsonPropertyName("doc_count")]
		public long DocCount
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("key")]
		public TKey Key
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("key_as_string")]
		public string KeyAsString
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	public partial class KeyedValueAggregate : Aggregations.ValueAggregate
	{
		[JsonInclude]
		[JsonPropertyName("keys")]
		public IReadOnlyCollection<string> Keys
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	public partial class LineStringGeoShape
	{
		[JsonInclude]
		[JsonPropertyName("coordinates")]
		public IReadOnlyCollection<Elastic.Clients.Elasticsearch.QueryDsl.GeoCoordinate> Coordinates
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	[ConvertAs(typeof(MatrixAggregation))]
	public partial interface IMatrixAggregation
	{
		Elastic.Clients.Elasticsearch.Fields? Fields { get; set; }

		Dictionary<Elastic.Clients.Elasticsearch.Field, double>? Missing { get; set; }
	}

	public partial class MatrixAggregationDescriptor : DescriptorBase<MatrixAggregationDescriptor, IMatrixAggregation>, IMatrixAggregation
	{
		Elastic.Clients.Elasticsearch.Fields? IMatrixAggregation.Fields { get; set; }

		Dictionary<Elastic.Clients.Elasticsearch.Field, double>? IMatrixAggregation.Missing { get; set; }
	}

	public partial class MatrixAggregation : Aggregations.Aggregation, IMatrixAggregation
	{
		[JsonInclude]
		[JsonPropertyName("fields")]
		public Elastic.Clients.Elasticsearch.Fields? Fields { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing")]
		public Dictionary<Elastic.Clients.Elasticsearch.Field, double>? Missing { get; set; }
	}

	public partial class MatrixStatsAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("correlation")]
		public Dictionary<string, double> Correlation
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("count")]
		public int Count
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("covariance")]
		public Dictionary<string, double> Covariance
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("kurtosis")]
		public double Kurtosis
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("mean")]
		public double Mean
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("name")]
		public string Name
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("skewness")]
		public double Skewness
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("variance")]
		public double Variance
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	[ConvertAs(typeof(MatrixStatsAggregation))]
	public partial interface IMatrixStatsAggregation
	{
		Elastic.Clients.Elasticsearch.Aggregations.MatrixStatsMode? Mode { get; set; }
	}

	public partial class MatrixStatsAggregationDescriptor : DescriptorBase<MatrixStatsAggregationDescriptor, IMatrixStatsAggregation>, IMatrixStatsAggregation
	{
		Elastic.Clients.Elasticsearch.Aggregations.MatrixStatsMode? IMatrixStatsAggregation.Mode { get; set; }
	}

	public partial class MatrixStatsAggregation : Aggregations.MatrixAggregation, IMatrixStatsAggregation
	{
		[JsonInclude]
		[JsonPropertyName("mode")]
		public Elastic.Clients.Elasticsearch.Aggregations.MatrixStatsMode? Mode { get; set; }
	}

	[ConvertAs(typeof(MaxAggregation))]
	public partial interface IMaxAggregation
	{
	}

	public partial class MaxAggregationDescriptor : DescriptorBase<MaxAggregationDescriptor, IMaxAggregation>, IMaxAggregation
	{
	}

	public partial class MaxAggregation : Aggregations.FormatMetricAggregationBase, IMaxAggregation
	{
	}

	[ConvertAs(typeof(MaxBucketAggregation))]
	public partial interface IMaxBucketAggregation
	{
	}

	public partial class MaxBucketAggregationDescriptor : DescriptorBase<MaxBucketAggregationDescriptor, IMaxBucketAggregation>, IMaxBucketAggregation
	{
	}

	public partial class MaxBucketAggregation : Aggregations.PipelineAggregationBase, IMaxBucketAggregation
	{
	}

	[ConvertAs(typeof(MedianAbsoluteDeviationAggregation))]
	public partial interface IMedianAbsoluteDeviationAggregation
	{
		double? Compression { get; set; }
	}

	public partial class MedianAbsoluteDeviationAggregationDescriptor : DescriptorBase<MedianAbsoluteDeviationAggregationDescriptor, IMedianAbsoluteDeviationAggregation>, IMedianAbsoluteDeviationAggregation
	{
		double? IMedianAbsoluteDeviationAggregation.Compression { get; set; }
	}

	public partial class MedianAbsoluteDeviationAggregation : Aggregations.FormatMetricAggregationBase, IMedianAbsoluteDeviationAggregation
	{
		[JsonInclude]
		[JsonPropertyName("compression")]
		public double? Compression { get; set; }
	}

	[ConvertAs(typeof(MetricAggregationBase))]
	public partial interface IMetricAggregationBase
	{
		Elastic.Clients.Elasticsearch.Field? Field { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.Missing? Missing { get; set; }

		Elastic.Clients.Elasticsearch.Script? Script { get; set; }
	}

	public partial class MetricAggregationBaseDescriptor : DescriptorBase<MetricAggregationBaseDescriptor, IMetricAggregationBase>, IMetricAggregationBase
	{
		Elastic.Clients.Elasticsearch.Field? IMetricAggregationBase.Field { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.Missing? IMetricAggregationBase.Missing { get; set; }

		Elastic.Clients.Elasticsearch.Script? IMetricAggregationBase.Script { get; set; }
	}

	public abstract partial class MetricAggregationBase : IMetricAggregationBase
	{
		[JsonInclude]
		[JsonPropertyName("field")]
		public Elastic.Clients.Elasticsearch.Field? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing")]
		public Elastic.Clients.Elasticsearch.Aggregations.Missing? Missing { get; set; }

		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script? Script { get; set; }
	}

	[ConvertAs(typeof(MinAggregation))]
	public partial interface IMinAggregation
	{
	}

	public partial class MinAggregationDescriptor : DescriptorBase<MinAggregationDescriptor, IMinAggregation>, IMinAggregation
	{
	}

	public partial class MinAggregation : Aggregations.FormatMetricAggregationBase, IMinAggregation
	{
	}

	[ConvertAs(typeof(MinBucketAggregation))]
	public partial interface IMinBucketAggregation
	{
	}

	public partial class MinBucketAggregationDescriptor : DescriptorBase<MinBucketAggregationDescriptor, IMinBucketAggregation>, IMinBucketAggregation
	{
	}

	public partial class MinBucketAggregation : Aggregations.PipelineAggregationBase, IMinBucketAggregation
	{
	}

	[ConvertAs(typeof(MissingAggregation))]
	public partial interface IMissingAggregation
	{
		Elastic.Clients.Elasticsearch.Field? Field { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.Missing? Missing { get; set; }
	}

	public partial class MissingAggregationDescriptor : DescriptorBase<MissingAggregationDescriptor, IMissingAggregation>, IMissingAggregation
	{
		Elastic.Clients.Elasticsearch.Field? IMissingAggregation.Field { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.Missing? IMissingAggregation.Missing { get; set; }
	}

	public partial class MissingAggregation : Aggregations.BucketAggregationBase, IMissingAggregation
	{
		[JsonInclude]
		[JsonPropertyName("field")]
		public Elastic.Clients.Elasticsearch.Field? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing")]
		public Elastic.Clients.Elasticsearch.Aggregations.Missing? Missing { get; set; }
	}

	[ConvertAs(typeof(MovingAverageAggregation))]
	public partial interface IMovingAverageAggregation
	{
		bool? Minimize { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.MovingAverageModel? Model { get; set; }

		int? Predict { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.MovingAverageSettings Settings { get; set; }

		int? Window { get; set; }
	}

	public partial class MovingAverageAggregationDescriptor : DescriptorBase<MovingAverageAggregationDescriptor, IMovingAverageAggregation>, IMovingAverageAggregation
	{
		bool? IMovingAverageAggregation.Minimize { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.MovingAverageModel? IMovingAverageAggregation.Model { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.MovingAverageSettings IMovingAverageAggregation.Settings { get; set; }

		int? IMovingAverageAggregation.Predict { get; set; }

		int? IMovingAverageAggregation.Window { get; set; }
	}

	public partial class MovingAverageAggregation : Aggregations.PipelineAggregationBase, IMovingAverageAggregation
	{
		[JsonInclude]
		[JsonPropertyName("minimize")]
		public bool? Minimize { get; set; }

		[JsonInclude]
		[JsonPropertyName("model")]
		public Elastic.Clients.Elasticsearch.Aggregations.MovingAverageModel? Model { get; set; }

		[JsonInclude]
		[JsonPropertyName("predict")]
		public int? Predict { get; set; }

		[JsonInclude]
		[JsonPropertyName("settings")]
		public Elastic.Clients.Elasticsearch.Aggregations.MovingAverageSettings Settings { get; set; }

		[JsonInclude]
		[JsonPropertyName("window")]
		public int? Window { get; set; }
	}

	[ConvertAs(typeof(MovingFunctionAggregation))]
	public partial interface IMovingFunctionAggregation
	{
		string? Script { get; set; }

		int? Shift { get; set; }

		int? Window { get; set; }
	}

	public partial class MovingFunctionAggregationDescriptor : DescriptorBase<MovingFunctionAggregationDescriptor, IMovingFunctionAggregation>, IMovingFunctionAggregation
	{
		string? IMovingFunctionAggregation.Script { get; set; }

		int? IMovingFunctionAggregation.Shift { get; set; }

		int? IMovingFunctionAggregation.Window { get; set; }
	}

	public partial class MovingFunctionAggregation : Aggregations.PipelineAggregationBase, IMovingFunctionAggregation
	{
		[JsonInclude]
		[JsonPropertyName("script")]
		public string? Script { get; set; }

		[JsonInclude]
		[JsonPropertyName("shift")]
		public int? Shift { get; set; }

		[JsonInclude]
		[JsonPropertyName("window")]
		public int? Window { get; set; }
	}

	[ConvertAs(typeof(MovingPercentilesAggregation))]
	public partial interface IMovingPercentilesAggregation
	{
		bool? Keyed { get; set; }

		int? Shift { get; set; }

		int? Window { get; set; }
	}

	public partial class MovingPercentilesAggregationDescriptor : DescriptorBase<MovingPercentilesAggregationDescriptor, IMovingPercentilesAggregation>, IMovingPercentilesAggregation
	{
		int? IMovingPercentilesAggregation.Window { get; set; }

		int? IMovingPercentilesAggregation.Shift { get; set; }

		bool? IMovingPercentilesAggregation.Keyed { get; set; }
	}

	public partial class MovingPercentilesAggregation : Aggregations.PipelineAggregationBase, IMovingPercentilesAggregation
	{
		[JsonInclude]
		[JsonPropertyName("keyed")]
		public bool? Keyed { get; set; }

		[JsonInclude]
		[JsonPropertyName("shift")]
		public int? Shift { get; set; }

		[JsonInclude]
		[JsonPropertyName("window")]
		public int? Window { get; set; }
	}

	public partial class MultiBucketAggregate<TBucket> : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("buckets")]
		public IReadOnlyCollection<TBucket> Buckets
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	[ConvertAs(typeof(MultiTermLookup))]
	public partial interface IMultiTermLookup
	{
		Elastic.Clients.Elasticsearch.Field Field { get; set; }
	}

	public partial class MultiTermLookupDescriptor : DescriptorBase<MultiTermLookupDescriptor, IMultiTermLookup>, IMultiTermLookup
	{
		Elastic.Clients.Elasticsearch.Field IMultiTermLookup.Field { get; set; }
	}

	public partial class MultiTermLookup : IMultiTermLookup
	{
		[JsonInclude]
		[JsonPropertyName("field")]
		public Elastic.Clients.Elasticsearch.Field Field { get; set; }
	}

	[ConvertAs(typeof(MultiTermsAggregation))]
	public partial interface IMultiTermsAggregation
	{
		IEnumerable<Elastic.Clients.Elasticsearch.Aggregations.IMultiTermLookup> Terms { get; set; }
	}

	public partial class MultiTermsAggregationDescriptor : DescriptorBase<MultiTermsAggregationDescriptor, IMultiTermsAggregation>, IMultiTermsAggregation
	{
		IEnumerable<Elastic.Clients.Elasticsearch.Aggregations.IMultiTermLookup> IMultiTermsAggregation.Terms { get; set; }
	}

	public partial class MultiTermsAggregation : Aggregations.BucketAggregationBase, IMultiTermsAggregation
	{
		[JsonInclude]
		[JsonPropertyName("terms")]
		public IEnumerable<Elastic.Clients.Elasticsearch.Aggregations.IMultiTermLookup> Terms { get; set; }
	}

	[ConvertAs(typeof(MutualInformationHeuristic))]
	public partial interface IMutualInformationHeuristic
	{
		bool BackgroundIsSuperset { get; set; }

		bool IncludeNegatives { get; set; }
	}

	public partial class MutualInformationHeuristicDescriptor : DescriptorBase<MutualInformationHeuristicDescriptor, IMutualInformationHeuristic>, IMutualInformationHeuristic
	{
		bool IMutualInformationHeuristic.BackgroundIsSuperset { get; set; }

		bool IMutualInformationHeuristic.IncludeNegatives { get; set; }
	}

	public partial class MutualInformationHeuristic : IMutualInformationHeuristic
	{
		[JsonInclude]
		[JsonPropertyName("background_is_superset")]
		public bool BackgroundIsSuperset { get; set; }

		[JsonInclude]
		[JsonPropertyName("include_negatives")]
		public bool IncludeNegatives { get; set; }
	}

	[ConvertAs(typeof(NestedAggregation))]
	public partial interface INestedAggregation
	{
		Elastic.Clients.Elasticsearch.Field? Path { get; set; }
	}

	public partial class NestedAggregationDescriptor : DescriptorBase<NestedAggregationDescriptor, INestedAggregation>, INestedAggregation
	{
		Elastic.Clients.Elasticsearch.Field? INestedAggregation.Path { get; set; }
	}

	public partial class NestedAggregation : Aggregations.BucketAggregationBase, INestedAggregation
	{
		[JsonInclude]
		[JsonPropertyName("path")]
		public Elastic.Clients.Elasticsearch.Field? Path { get; set; }
	}

	[ConvertAs(typeof(NormalizeAggregation))]
	public partial interface INormalizeAggregation
	{
		Elastic.Clients.Elasticsearch.Aggregations.NormalizeMethod? Method { get; set; }
	}

	public partial class NormalizeAggregationDescriptor : DescriptorBase<NormalizeAggregationDescriptor, INormalizeAggregation>, INormalizeAggregation
	{
		Elastic.Clients.Elasticsearch.Aggregations.NormalizeMethod? INormalizeAggregation.Method { get; set; }
	}

	public partial class NormalizeAggregation : Aggregations.PipelineAggregationBase, INormalizeAggregation
	{
		[JsonInclude]
		[JsonPropertyName("method")]
		public Elastic.Clients.Elasticsearch.Aggregations.NormalizeMethod? Method { get; set; }
	}

	[ConvertAs(typeof(ParentAggregation))]
	public partial interface IParentAggregation
	{
		Elastic.Clients.Elasticsearch.RelationName? Type { get; set; }
	}

	public partial class ParentAggregationDescriptor : DescriptorBase<ParentAggregationDescriptor, IParentAggregation>, IParentAggregation
	{
		Elastic.Clients.Elasticsearch.RelationName? IParentAggregation.Type { get; set; }
	}

	public partial class ParentAggregation : Aggregations.BucketAggregationBase, IParentAggregation
	{
		[JsonInclude]
		[JsonPropertyName("type")]
		public Elastic.Clients.Elasticsearch.RelationName? Type { get; set; }
	}

	[ConvertAs(typeof(PercentageScoreHeuristic))]
	public partial interface IPercentageScoreHeuristic
	{
	}

	public partial class PercentageScoreHeuristicDescriptor : DescriptorBase<PercentageScoreHeuristicDescriptor, IPercentageScoreHeuristic>, IPercentageScoreHeuristic
	{
	}

	public partial class PercentageScoreHeuristic : IPercentageScoreHeuristic
	{
	}

	public partial class PercentileItem
	{
		[JsonInclude]
		[JsonPropertyName("percentile")]
		public double Percentile
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("value")]
		public double Value
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	[ConvertAs(typeof(PercentileRanksAggregation))]
	public partial interface IPercentileRanksAggregation
	{
		Elastic.Clients.Elasticsearch.Aggregations.IHdrMethod? Hdr { get; set; }

		bool? Keyed { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.ITDigest? Tdigest { get; set; }

		IEnumerable<double>? Values { get; set; }
	}

	public partial class PercentileRanksAggregationDescriptor : DescriptorBase<PercentileRanksAggregationDescriptor, IPercentileRanksAggregation>, IPercentileRanksAggregation
	{
		bool? IPercentileRanksAggregation.Keyed { get; set; }

		IEnumerable<double>? IPercentileRanksAggregation.Values { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.IHdrMethod? IPercentileRanksAggregation.Hdr { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.ITDigest? IPercentileRanksAggregation.Tdigest { get; set; }
	}

	public partial class PercentileRanksAggregation : Aggregations.FormatMetricAggregationBase, IPercentileRanksAggregation
	{
		[JsonInclude]
		[JsonPropertyName("hdr")]
		public Elastic.Clients.Elasticsearch.Aggregations.IHdrMethod? Hdr { get; set; }

		[JsonInclude]
		[JsonPropertyName("keyed")]
		public bool? Keyed { get; set; }

		[JsonInclude]
		[JsonPropertyName("tdigest")]
		public Elastic.Clients.Elasticsearch.Aggregations.ITDigest? Tdigest { get; set; }

		[JsonInclude]
		[JsonPropertyName("values")]
		public IEnumerable<double>? Values { get; set; }
	}

	public partial class PercentilesAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("items")]
		public IReadOnlyCollection<Elastic.Clients.Elasticsearch.Aggregations.PercentileItem> Items
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	[ConvertAs(typeof(PercentilesAggregation))]
	public partial interface IPercentilesAggregation
	{
		Elastic.Clients.Elasticsearch.Aggregations.IHdrMethod? Hdr { get; set; }

		bool? Keyed { get; set; }

		IEnumerable<double>? Percents { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.ITDigest? Tdigest { get; set; }
	}

	public partial class PercentilesAggregationDescriptor : DescriptorBase<PercentilesAggregationDescriptor, IPercentilesAggregation>, IPercentilesAggregation
	{
		bool? IPercentilesAggregation.Keyed { get; set; }

		IEnumerable<double>? IPercentilesAggregation.Percents { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.IHdrMethod? IPercentilesAggregation.Hdr { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.ITDigest? IPercentilesAggregation.Tdigest { get; set; }
	}

	public partial class PercentilesAggregation : Aggregations.FormatMetricAggregationBase, IPercentilesAggregation
	{
		[JsonInclude]
		[JsonPropertyName("hdr")]
		public Elastic.Clients.Elasticsearch.Aggregations.IHdrMethod? Hdr { get; set; }

		[JsonInclude]
		[JsonPropertyName("keyed")]
		public bool? Keyed { get; set; }

		[JsonInclude]
		[JsonPropertyName("percents")]
		public IEnumerable<double>? Percents { get; set; }

		[JsonInclude]
		[JsonPropertyName("tdigest")]
		public Elastic.Clients.Elasticsearch.Aggregations.ITDigest? Tdigest { get; set; }
	}

	[ConvertAs(typeof(PercentilesBucketAggregation))]
	public partial interface IPercentilesBucketAggregation
	{
		IEnumerable<double>? Percents { get; set; }
	}

	public partial class PercentilesBucketAggregationDescriptor : DescriptorBase<PercentilesBucketAggregationDescriptor, IPercentilesBucketAggregation>, IPercentilesBucketAggregation
	{
		IEnumerable<double>? IPercentilesBucketAggregation.Percents { get; set; }
	}

	public partial class PercentilesBucketAggregation : Aggregations.PipelineAggregationBase, IPercentilesBucketAggregation
	{
		[JsonInclude]
		[JsonPropertyName("percents")]
		public IEnumerable<double>? Percents { get; set; }
	}

	[ConvertAs(typeof(PipelineAggregationBase))]
	public partial interface IPipelineAggregationBase
	{
		Elastic.Clients.Elasticsearch.Aggregations.IBucketsPath? BucketsPath { get; set; }

		string? Format { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.GapPolicy? GapPolicy { get; set; }
	}

	public partial class PipelineAggregationBaseDescriptor : DescriptorBase<PipelineAggregationBaseDescriptor, IPipelineAggregationBase>, IPipelineAggregationBase
	{
		Elastic.Clients.Elasticsearch.Aggregations.IBucketsPath? IPipelineAggregationBase.BucketsPath { get; set; }

		string? IPipelineAggregationBase.Format { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.GapPolicy? IPipelineAggregationBase.GapPolicy { get; set; }
	}

	public abstract partial class PipelineAggregationBase : Aggregations.Aggregation, IPipelineAggregationBase
	{
		[JsonInclude]
		[JsonPropertyName("buckets_path")]
		public Elastic.Clients.Elasticsearch.Aggregations.IBucketsPath? BucketsPath { get; set; }

		[JsonInclude]
		[JsonPropertyName("format")]
		public string? Format { get; set; }

		[JsonInclude]
		[JsonPropertyName("gap_policy")]
		public Elastic.Clients.Elasticsearch.Aggregations.GapPolicy? GapPolicy { get; set; }
	}

	[ConvertAs(typeof(RangeAggregation))]
	public partial interface IRangeAggregation
	{
		Elastic.Clients.Elasticsearch.Field? Field { get; set; }

		bool? Keyed { get; set; }

		IEnumerable<Elastic.Clients.Elasticsearch.Aggregations.IAggregationRange>? Ranges { get; set; }

		Elastic.Clients.Elasticsearch.Script? Script { get; set; }
	}

	public partial class RangeAggregationDescriptor : DescriptorBase<RangeAggregationDescriptor, IRangeAggregation>, IRangeAggregation
	{
		Elastic.Clients.Elasticsearch.Field? IRangeAggregation.Field { get; set; }

		IEnumerable<Elastic.Clients.Elasticsearch.Aggregations.IAggregationRange>? IRangeAggregation.Ranges { get; set; }

		Elastic.Clients.Elasticsearch.Script? IRangeAggregation.Script { get; set; }

		bool? IRangeAggregation.Keyed { get; set; }
	}

	public partial class RangeAggregation : Aggregations.BucketAggregationBase, IRangeAggregation
	{
		[JsonInclude]
		[JsonPropertyName("field")]
		public Elastic.Clients.Elasticsearch.Field? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("keyed")]
		public bool? Keyed { get; set; }

		[JsonInclude]
		[JsonPropertyName("ranges")]
		public IEnumerable<Elastic.Clients.Elasticsearch.Aggregations.IAggregationRange>? Ranges { get; set; }

		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script? Script { get; set; }
	}

	public partial class RangeBucket
	{
	}

	[ConvertAs(typeof(RareTermsAggregation))]
	public partial interface IRareTermsAggregation
	{
		IEnumerable<string>? Exclude { get; set; }

		Elastic.Clients.Elasticsearch.Field? Field { get; set; }

		long? MaxDocCount { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.Missing? Missing { get; set; }

		double? Precision { get; set; }

		string? ValueType { get; set; }
	}

	public partial class RareTermsAggregationDescriptor : DescriptorBase<RareTermsAggregationDescriptor, IRareTermsAggregation>, IRareTermsAggregation
	{
		IEnumerable<string>? IRareTermsAggregation.Exclude { get; set; }

		Elastic.Clients.Elasticsearch.Field? IRareTermsAggregation.Field { get; set; }

		long? IRareTermsAggregation.MaxDocCount { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.Missing? IRareTermsAggregation.Missing { get; set; }

		double? IRareTermsAggregation.Precision { get; set; }

		string? IRareTermsAggregation.ValueType { get; set; }
	}

	public partial class RareTermsAggregation : Aggregations.BucketAggregationBase, IRareTermsAggregation
	{
		[JsonInclude]
		[JsonPropertyName("exclude")]
		public IEnumerable<string>? Exclude { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public Elastic.Clients.Elasticsearch.Field? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("include")]
		public OneOf<string, IReadOnlyCollection<string>, Aggregations.TermsInclude>? Include { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_doc_count")]
		public long? MaxDocCount { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing")]
		public Elastic.Clients.Elasticsearch.Aggregations.Missing? Missing { get; set; }

		[JsonInclude]
		[JsonPropertyName("precision")]
		public double? Precision { get; set; }

		[JsonInclude]
		[JsonPropertyName("value_type")]
		public string? ValueType { get; set; }
	}

	public partial class RareTermsBucket<TKey>
	{
	}

	[ConvertAs(typeof(RateAggregation))]
	public partial interface IRateAggregation
	{
		Elastic.Clients.Elasticsearch.Aggregations.RateMode? Mode { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.DateInterval? Unit { get; set; }
	}

	public partial class RateAggregationDescriptor : DescriptorBase<RateAggregationDescriptor, IRateAggregation>, IRateAggregation
	{
		Elastic.Clients.Elasticsearch.Aggregations.DateInterval? IRateAggregation.Unit { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.RateMode? IRateAggregation.Mode { get; set; }
	}

	public partial class RateAggregation : Aggregations.FormatMetricAggregationBase, IRateAggregation
	{
		[JsonInclude]
		[JsonPropertyName("mode")]
		public Elastic.Clients.Elasticsearch.Aggregations.RateMode? Mode { get; set; }

		[JsonInclude]
		[JsonPropertyName("unit")]
		public Elastic.Clients.Elasticsearch.Aggregations.DateInterval? Unit { get; set; }
	}

	[ConvertAs(typeof(RegressionInferenceOptions))]
	public partial interface IRegressionInferenceOptions
	{
		int? NumTopFeatureImportanceValues { get; set; }

		Elastic.Clients.Elasticsearch.Field? ResultsField { get; set; }
	}

	public partial class RegressionInferenceOptionsDescriptor : DescriptorBase<RegressionInferenceOptionsDescriptor, IRegressionInferenceOptions>, IRegressionInferenceOptions
	{
		Elastic.Clients.Elasticsearch.Field? IRegressionInferenceOptions.ResultsField { get; set; }

		int? IRegressionInferenceOptions.NumTopFeatureImportanceValues { get; set; }
	}

	public partial class RegressionInferenceOptions : IRegressionInferenceOptions
	{
		[JsonInclude]
		[JsonPropertyName("num_top_feature_importance_values")]
		public int? NumTopFeatureImportanceValues { get; set; }

		[JsonInclude]
		[JsonPropertyName("results_field")]
		public Elastic.Clients.Elasticsearch.Field? ResultsField { get; set; }
	}

	[ConvertAs(typeof(ReverseNestedAggregation))]
	public partial interface IReverseNestedAggregation
	{
		Elastic.Clients.Elasticsearch.Field? Path { get; set; }
	}

	public partial class ReverseNestedAggregationDescriptor : DescriptorBase<ReverseNestedAggregationDescriptor, IReverseNestedAggregation>, IReverseNestedAggregation
	{
		Elastic.Clients.Elasticsearch.Field? IReverseNestedAggregation.Path { get; set; }
	}

	public partial class ReverseNestedAggregation : Aggregations.BucketAggregationBase, IReverseNestedAggregation
	{
		[JsonInclude]
		[JsonPropertyName("path")]
		public Elastic.Clients.Elasticsearch.Field? Path { get; set; }
	}

	[ConvertAs(typeof(SamplerAggregation))]
	public partial interface ISamplerAggregation
	{
		int? ShardSize { get; set; }
	}

	public partial class SamplerAggregationDescriptor : DescriptorBase<SamplerAggregationDescriptor, ISamplerAggregation>, ISamplerAggregation
	{
		int? ISamplerAggregation.ShardSize { get; set; }
	}

	public partial class SamplerAggregation : Aggregations.BucketAggregationBase, ISamplerAggregation
	{
		[JsonInclude]
		[JsonPropertyName("shard_size")]
		public int? ShardSize { get; set; }
	}

	[ConvertAs(typeof(ScriptedHeuristic))]
	public partial interface IScriptedHeuristic
	{
		Elastic.Clients.Elasticsearch.Script Script { get; set; }
	}

	public partial class ScriptedHeuristicDescriptor : DescriptorBase<ScriptedHeuristicDescriptor, IScriptedHeuristic>, IScriptedHeuristic
	{
		Elastic.Clients.Elasticsearch.Script IScriptedHeuristic.Script { get; set; }
	}

	public partial class ScriptedHeuristic : IScriptedHeuristic
	{
		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script Script { get; set; }
	}

	public partial class ScriptedMetricAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("value")]
		public object Value
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	[ConvertAs(typeof(ScriptedMetricAggregation))]
	public partial interface IScriptedMetricAggregation
	{
		Elastic.Clients.Elasticsearch.Script? CombineScript { get; set; }

		Elastic.Clients.Elasticsearch.Script? InitScript { get; set; }

		Elastic.Clients.Elasticsearch.Script? MapScript { get; set; }

		Dictionary<string, object>? Params { get; set; }

		Elastic.Clients.Elasticsearch.Script? ReduceScript { get; set; }
	}

	public partial class ScriptedMetricAggregationDescriptor : DescriptorBase<ScriptedMetricAggregationDescriptor, IScriptedMetricAggregation>, IScriptedMetricAggregation
	{
		Elastic.Clients.Elasticsearch.Script? IScriptedMetricAggregation.CombineScript { get; set; }

		Elastic.Clients.Elasticsearch.Script? IScriptedMetricAggregation.InitScript { get; set; }

		Elastic.Clients.Elasticsearch.Script? IScriptedMetricAggregation.MapScript { get; set; }

		Dictionary<string, object>? IScriptedMetricAggregation.Params { get; set; }

		Elastic.Clients.Elasticsearch.Script? IScriptedMetricAggregation.ReduceScript { get; set; }
	}

	public partial class ScriptedMetricAggregation : Aggregations.MetricAggregationBase, IScriptedMetricAggregation
	{
		[JsonInclude]
		[JsonPropertyName("combine_script")]
		public Elastic.Clients.Elasticsearch.Script? CombineScript { get; set; }

		[JsonInclude]
		[JsonPropertyName("init_script")]
		public Elastic.Clients.Elasticsearch.Script? InitScript { get; set; }

		[JsonInclude]
		[JsonPropertyName("map_script")]
		public Elastic.Clients.Elasticsearch.Script? MapScript { get; set; }

		[JsonInclude]
		[JsonPropertyName("params")]
		public Dictionary<string, object>? Params { get; set; }

		[JsonInclude]
		[JsonPropertyName("reduce_script")]
		public Elastic.Clients.Elasticsearch.Script? ReduceScript { get; set; }
	}

	[ConvertAs(typeof(SerialDifferencingAggregation))]
	public partial interface ISerialDifferencingAggregation
	{
		int? Lag { get; set; }
	}

	public partial class SerialDifferencingAggregationDescriptor : DescriptorBase<SerialDifferencingAggregationDescriptor, ISerialDifferencingAggregation>, ISerialDifferencingAggregation
	{
		int? ISerialDifferencingAggregation.Lag { get; set; }
	}

	public partial class SerialDifferencingAggregation : Aggregations.PipelineAggregationBase, ISerialDifferencingAggregation
	{
		[JsonInclude]
		[JsonPropertyName("lag")]
		public int? Lag { get; set; }
	}

	public partial class SignificantTermsAggregate<TKey, TBucket> : Aggregations.MultiBucketAggregate<TBucket>
	{
		[JsonInclude]
		[JsonPropertyName("bg_count")]
		public long BgCount
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("doc_count")]
		public long DocCount
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	[ConvertAs(typeof(SignificantTermsAggregation))]
	public partial interface ISignificantTermsAggregation
	{
		Elastic.Clients.Elasticsearch.QueryDsl.IQueryContainer? BackgroundFilter { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.IChiSquareHeuristic? ChiSquare { get; set; }

		IEnumerable<string>? Exclude { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.TermsAggregationExecutionHint? ExecutionHint { get; set; }

		Elastic.Clients.Elasticsearch.Field? Field { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.IGoogleNormalizedDistanceHeuristic? Gnd { get; set; }

		IEnumerable<string>? Include { get; set; }

		long? MinDocCount { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.IMutualInformationHeuristic? MutualInformation { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.IPercentageScoreHeuristic? Percentage { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.IScriptedHeuristic? ScriptHeuristic { get; set; }

		long? ShardMinDocCount { get; set; }

		int? ShardSize { get; set; }

		int? Size { get; set; }
	}

	public partial class SignificantTermsAggregationDescriptor : DescriptorBase<SignificantTermsAggregationDescriptor, ISignificantTermsAggregation>, ISignificantTermsAggregation
	{
		Elastic.Clients.Elasticsearch.QueryDsl.IQueryContainer? ISignificantTermsAggregation.BackgroundFilter { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.IChiSquareHeuristic? ISignificantTermsAggregation.ChiSquare { get; set; }

		IEnumerable<string>? ISignificantTermsAggregation.Exclude { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.TermsAggregationExecutionHint? ISignificantTermsAggregation.ExecutionHint { get; set; }

		Elastic.Clients.Elasticsearch.Field? ISignificantTermsAggregation.Field { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.IGoogleNormalizedDistanceHeuristic? ISignificantTermsAggregation.Gnd { get; set; }

		IEnumerable<string>? ISignificantTermsAggregation.Include { get; set; }

		long? ISignificantTermsAggregation.MinDocCount { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.IMutualInformationHeuristic? ISignificantTermsAggregation.MutualInformation { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.IPercentageScoreHeuristic? ISignificantTermsAggregation.Percentage { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.IScriptedHeuristic? ISignificantTermsAggregation.ScriptHeuristic { get; set; }

		long? ISignificantTermsAggregation.ShardMinDocCount { get; set; }

		int? ISignificantTermsAggregation.ShardSize { get; set; }

		int? ISignificantTermsAggregation.Size { get; set; }
	}

	public partial class SignificantTermsAggregation : Aggregations.BucketAggregationBase, ISignificantTermsAggregation
	{
		[JsonInclude]
		[JsonPropertyName("background_filter")]
		public Elastic.Clients.Elasticsearch.QueryDsl.IQueryContainer? BackgroundFilter { get; set; }

		[JsonInclude]
		[JsonPropertyName("chi_square")]
		public Elastic.Clients.Elasticsearch.Aggregations.IChiSquareHeuristic? ChiSquare { get; set; }

		[JsonInclude]
		[JsonPropertyName("exclude")]
		public IEnumerable<string>? Exclude { get; set; }

		[JsonInclude]
		[JsonPropertyName("execution_hint")]
		public Elastic.Clients.Elasticsearch.Aggregations.TermsAggregationExecutionHint? ExecutionHint { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public Elastic.Clients.Elasticsearch.Field? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("gnd")]
		public Elastic.Clients.Elasticsearch.Aggregations.IGoogleNormalizedDistanceHeuristic? Gnd { get; set; }

		[JsonInclude]
		[JsonPropertyName("include")]
		public IEnumerable<string>? Include { get; set; }

		[JsonInclude]
		[JsonPropertyName("min_doc_count")]
		public long? MinDocCount { get; set; }

		[JsonInclude]
		[JsonPropertyName("mutual_information")]
		public Elastic.Clients.Elasticsearch.Aggregations.IMutualInformationHeuristic? MutualInformation { get; set; }

		[JsonInclude]
		[JsonPropertyName("percentage")]
		public Elastic.Clients.Elasticsearch.Aggregations.IPercentageScoreHeuristic? Percentage { get; set; }

		[JsonInclude]
		[JsonPropertyName("script_heuristic")]
		public Elastic.Clients.Elasticsearch.Aggregations.IScriptedHeuristic? ScriptHeuristic { get; set; }

		[JsonInclude]
		[JsonPropertyName("shard_min_doc_count")]
		public long? ShardMinDocCount { get; set; }

		[JsonInclude]
		[JsonPropertyName("shard_size")]
		public int? ShardSize { get; set; }

		[JsonInclude]
		[JsonPropertyName("size")]
		public int? Size { get; set; }
	}

	public partial class SignificantTermsBucket<TKey>
	{
	}

	[ConvertAs(typeof(SignificantTextAggregation))]
	public partial interface ISignificantTextAggregation
	{
		Elastic.Clients.Elasticsearch.QueryDsl.IQueryContainer? BackgroundFilter { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.IChiSquareHeuristic? ChiSquare { get; set; }

		IEnumerable<string>? Exclude { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.TermsAggregationExecutionHint? ExecutionHint { get; set; }

		Elastic.Clients.Elasticsearch.Field? Field { get; set; }

		bool? FilterDuplicateText { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.IGoogleNormalizedDistanceHeuristic? Gnd { get; set; }

		IEnumerable<string>? Include { get; set; }

		long? MinDocCount { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.IMutualInformationHeuristic? MutualInformation { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.IPercentageScoreHeuristic? Percentage { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.IScriptedHeuristic? ScriptHeuristic { get; set; }

		long? ShardMinDocCount { get; set; }

		int? ShardSize { get; set; }

		int? Size { get; set; }

		Elastic.Clients.Elasticsearch.Fields? SourceFields { get; set; }
	}

	public partial class SignificantTextAggregationDescriptor : DescriptorBase<SignificantTextAggregationDescriptor, ISignificantTextAggregation>, ISignificantTextAggregation
	{
		Elastic.Clients.Elasticsearch.QueryDsl.IQueryContainer? ISignificantTextAggregation.BackgroundFilter { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.IChiSquareHeuristic? ISignificantTextAggregation.ChiSquare { get; set; }

		IEnumerable<string>? ISignificantTextAggregation.Exclude { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.TermsAggregationExecutionHint? ISignificantTextAggregation.ExecutionHint { get; set; }

		Elastic.Clients.Elasticsearch.Field? ISignificantTextAggregation.Field { get; set; }

		bool? ISignificantTextAggregation.FilterDuplicateText { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.IGoogleNormalizedDistanceHeuristic? ISignificantTextAggregation.Gnd { get; set; }

		IEnumerable<string>? ISignificantTextAggregation.Include { get; set; }

		long? ISignificantTextAggregation.MinDocCount { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.IMutualInformationHeuristic? ISignificantTextAggregation.MutualInformation { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.IPercentageScoreHeuristic? ISignificantTextAggregation.Percentage { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.IScriptedHeuristic? ISignificantTextAggregation.ScriptHeuristic { get; set; }

		long? ISignificantTextAggregation.ShardMinDocCount { get; set; }

		int? ISignificantTextAggregation.ShardSize { get; set; }

		int? ISignificantTextAggregation.Size { get; set; }

		Elastic.Clients.Elasticsearch.Fields? ISignificantTextAggregation.SourceFields { get; set; }
	}

	public partial class SignificantTextAggregation : Aggregations.BucketAggregationBase, ISignificantTextAggregation
	{
		[JsonInclude]
		[JsonPropertyName("background_filter")]
		public Elastic.Clients.Elasticsearch.QueryDsl.IQueryContainer? BackgroundFilter { get; set; }

		[JsonInclude]
		[JsonPropertyName("chi_square")]
		public Elastic.Clients.Elasticsearch.Aggregations.IChiSquareHeuristic? ChiSquare { get; set; }

		[JsonInclude]
		[JsonPropertyName("exclude")]
		public IEnumerable<string>? Exclude { get; set; }

		[JsonInclude]
		[JsonPropertyName("execution_hint")]
		public Elastic.Clients.Elasticsearch.Aggregations.TermsAggregationExecutionHint? ExecutionHint { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public Elastic.Clients.Elasticsearch.Field? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("filter_duplicate_text")]
		public bool? FilterDuplicateText { get; set; }

		[JsonInclude]
		[JsonPropertyName("gnd")]
		public Elastic.Clients.Elasticsearch.Aggregations.IGoogleNormalizedDistanceHeuristic? Gnd { get; set; }

		[JsonInclude]
		[JsonPropertyName("include")]
		public IEnumerable<string>? Include { get; set; }

		[JsonInclude]
		[JsonPropertyName("min_doc_count")]
		public long? MinDocCount { get; set; }

		[JsonInclude]
		[JsonPropertyName("mutual_information")]
		public Elastic.Clients.Elasticsearch.Aggregations.IMutualInformationHeuristic? MutualInformation { get; set; }

		[JsonInclude]
		[JsonPropertyName("percentage")]
		public Elastic.Clients.Elasticsearch.Aggregations.IPercentageScoreHeuristic? Percentage { get; set; }

		[JsonInclude]
		[JsonPropertyName("script_heuristic")]
		public Elastic.Clients.Elasticsearch.Aggregations.IScriptedHeuristic? ScriptHeuristic { get; set; }

		[JsonInclude]
		[JsonPropertyName("shard_min_doc_count")]
		public long? ShardMinDocCount { get; set; }

		[JsonInclude]
		[JsonPropertyName("shard_size")]
		public int? ShardSize { get; set; }

		[JsonInclude]
		[JsonPropertyName("size")]
		public int? Size { get; set; }

		[JsonInclude]
		[JsonPropertyName("source_fields")]
		public Elastic.Clients.Elasticsearch.Fields? SourceFields { get; set; }
	}

	public partial class SingleBucketAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("doc_count")]
		public double DocCount
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	public partial class StandardDeviationBounds
	{
		[JsonInclude]
		[JsonPropertyName("lower")]
		public double? Lower
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("lower_population")]
		public double? LowerPopulation
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("lower_sampling")]
		public double? LowerSampling
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("upper")]
		public double? Upper
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("upper_population")]
		public double? UpperPopulation
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("upper_sampling")]
		public double? UpperSampling
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	public partial class StatsAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("avg")]
		public double? Avg
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("count")]
		public double Count
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("max")]
		public double? Max
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("min")]
		public double? Min
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("sum")]
		public double Sum
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	[ConvertAs(typeof(StatsAggregation))]
	public partial interface IStatsAggregation
	{
	}

	public partial class StatsAggregationDescriptor : DescriptorBase<StatsAggregationDescriptor, IStatsAggregation>, IStatsAggregation
	{
	}

	public partial class StatsAggregation : Aggregations.FormatMetricAggregationBase, IStatsAggregation
	{
	}

	[ConvertAs(typeof(StatsBucketAggregation))]
	public partial interface IStatsBucketAggregation
	{
	}

	public partial class StatsBucketAggregationDescriptor : DescriptorBase<StatsBucketAggregationDescriptor, IStatsBucketAggregation>, IStatsBucketAggregation
	{
	}

	public partial class StatsBucketAggregation : Aggregations.PipelineAggregationBase, IStatsBucketAggregation
	{
	}

	public partial class StringStatsAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("avg_length")]
		public double AvgLength
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("count")]
		public long Count
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("distribution")]
		public Dictionary<string, double>? Distribution
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("entropy")]
		public double Entropy
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("max_length")]
		public int MaxLength
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("min_length")]
		public int MinLength
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	[ConvertAs(typeof(StringStatsAggregation))]
	public partial interface IStringStatsAggregation
	{
		bool? ShowDistribution { get; set; }
	}

	public partial class StringStatsAggregationDescriptor : DescriptorBase<StringStatsAggregationDescriptor, IStringStatsAggregation>, IStringStatsAggregation
	{
		bool? IStringStatsAggregation.ShowDistribution { get; set; }
	}

	public partial class StringStatsAggregation : Aggregations.MetricAggregationBase, IStringStatsAggregation
	{
		[JsonInclude]
		[JsonPropertyName("show_distribution")]
		public bool? ShowDistribution { get; set; }
	}

	[ConvertAs(typeof(SumAggregation))]
	public partial interface ISumAggregation
	{
	}

	public partial class SumAggregationDescriptor : DescriptorBase<SumAggregationDescriptor, ISumAggregation>, ISumAggregation
	{
	}

	public partial class SumAggregation : Aggregations.FormatMetricAggregationBase, ISumAggregation
	{
	}

	[ConvertAs(typeof(SumBucketAggregation))]
	public partial interface ISumBucketAggregation
	{
	}

	public partial class SumBucketAggregationDescriptor : DescriptorBase<SumBucketAggregationDescriptor, ISumBucketAggregation>, ISumBucketAggregation
	{
	}

	public partial class SumBucketAggregation : Aggregations.PipelineAggregationBase, ISumBucketAggregation
	{
	}

	[ConvertAs(typeof(TDigest))]
	public partial interface ITDigest
	{
		int? Compression { get; set; }
	}

	public partial class TDigestDescriptor : DescriptorBase<TDigestDescriptor, ITDigest>, ITDigest
	{
		int? ITDigest.Compression { get; set; }
	}

	public partial class TDigest : ITDigest
	{
		[JsonInclude]
		[JsonPropertyName("compression")]
		public int? Compression { get; set; }
	}

	public partial class TDigestPercentilesAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("values")]
		public Dictionary<string, double> Values
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	[ConvertAs(typeof(TTestAggregation))]
	public partial interface ITTestAggregation
	{
		Elastic.Clients.Elasticsearch.Aggregations.ITestPopulation? a { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.ITestPopulation? b { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.TTestType? Type { get; set; }
	}

	public partial class TTestAggregationDescriptor : DescriptorBase<TTestAggregationDescriptor, ITTestAggregation>, ITTestAggregation
	{
		Elastic.Clients.Elasticsearch.Aggregations.ITestPopulation? ITTestAggregation.a { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.ITestPopulation? ITTestAggregation.b { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.TTestType? ITTestAggregation.Type { get; set; }
	}

	public partial class TTestAggregation : Aggregations.Aggregation, ITTestAggregation
	{
		[JsonInclude]
		[JsonPropertyName("a")]
		public Elastic.Clients.Elasticsearch.Aggregations.ITestPopulation? a { get; set; }

		[JsonInclude]
		[JsonPropertyName("b")]
		public Elastic.Clients.Elasticsearch.Aggregations.ITestPopulation? b { get; set; }

		[JsonInclude]
		[JsonPropertyName("type")]
		public Elastic.Clients.Elasticsearch.Aggregations.TTestType? Type { get; set; }
	}

	public partial class TermsAggregate<TKey, TBucket> : Aggregations.MultiBucketAggregate<TBucket>
	{
		[JsonInclude]
		[JsonPropertyName("doc_count_error_upper_bound")]
		public long DocCountErrorUpperBound
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("sum_other_doc_count")]
		public long SumOtherDocCount
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	[ConvertAs(typeof(TermsAggregation))]
	public partial interface ITermsAggregation
	{
		Elastic.Clients.Elasticsearch.Aggregations.TermsAggregationCollectMode? CollectMode { get; set; }

		IEnumerable<string>? Exclude { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.TermsAggregationExecutionHint? ExecutionHint { get; set; }

		Elastic.Clients.Elasticsearch.Field? Field { get; set; }

		int? MinDocCount { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.Missing? Missing { get; set; }

		bool? MissingBucket { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.TermsAggregationOrder? Order { get; set; }

		Elastic.Clients.Elasticsearch.Script? Script { get; set; }

		int? ShardSize { get; set; }

		bool? ShowTermDocCountError { get; set; }

		int? Size { get; set; }

		string? ValueType { get; set; }
	}

	public partial class TermsAggregationDescriptor : DescriptorBase<TermsAggregationDescriptor, ITermsAggregation>, ITermsAggregation
	{
		Elastic.Clients.Elasticsearch.Aggregations.TermsAggregationCollectMode? ITermsAggregation.CollectMode { get; set; }

		IEnumerable<string>? ITermsAggregation.Exclude { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.TermsAggregationExecutionHint? ITermsAggregation.ExecutionHint { get; set; }

		Elastic.Clients.Elasticsearch.Field? ITermsAggregation.Field { get; set; }

		int? ITermsAggregation.MinDocCount { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.Missing? ITermsAggregation.Missing { get; set; }

		bool? ITermsAggregation.MissingBucket { get; set; }

		string? ITermsAggregation.ValueType { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.TermsAggregationOrder? ITermsAggregation.Order { get; set; }

		Elastic.Clients.Elasticsearch.Script? ITermsAggregation.Script { get; set; }

		int? ITermsAggregation.ShardSize { get; set; }

		bool? ITermsAggregation.ShowTermDocCountError { get; set; }

		int? ITermsAggregation.Size { get; set; }
	}

	public partial class TermsAggregation : Aggregations.BucketAggregationBase, ITermsAggregation
	{
		[JsonInclude]
		[JsonPropertyName("collect_mode")]
		public Elastic.Clients.Elasticsearch.Aggregations.TermsAggregationCollectMode? CollectMode { get; set; }

		[JsonInclude]
		[JsonPropertyName("exclude")]
		public IEnumerable<string>? Exclude { get; set; }

		[JsonInclude]
		[JsonPropertyName("execution_hint")]
		public Elastic.Clients.Elasticsearch.Aggregations.TermsAggregationExecutionHint? ExecutionHint { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public Elastic.Clients.Elasticsearch.Field? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("include")]
		public OneOf<string, IReadOnlyCollection<string>, Aggregations.TermsInclude>? Include { get; set; }

		[JsonInclude]
		[JsonPropertyName("min_doc_count")]
		public int? MinDocCount { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing")]
		public Elastic.Clients.Elasticsearch.Aggregations.Missing? Missing { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing_bucket")]
		public bool? MissingBucket { get; set; }

		[JsonInclude]
		[JsonPropertyName("order")]
		public Elastic.Clients.Elasticsearch.Aggregations.TermsAggregationOrder? Order { get; set; }

		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script? Script { get; set; }

		[JsonInclude]
		[JsonPropertyName("shard_size")]
		public int? ShardSize { get; set; }

		[JsonInclude]
		[JsonPropertyName("show_term_doc_count_error")]
		public bool? ShowTermDocCountError { get; set; }

		[JsonInclude]
		[JsonPropertyName("size")]
		public int? Size { get; set; }

		[JsonInclude]
		[JsonPropertyName("value_type")]
		public string? ValueType { get; set; }
	}

	[ConvertAs(typeof(TermsInclude))]
	public partial interface ITermsInclude
	{
		long NumPartitions { get; set; }

		long Partition { get; set; }
	}

	public partial class TermsIncludeDescriptor : DescriptorBase<TermsIncludeDescriptor, ITermsInclude>, ITermsInclude
	{
		long ITermsInclude.NumPartitions { get; set; }

		long ITermsInclude.Partition { get; set; }
	}

	public partial class TermsInclude : ITermsInclude
	{
		[JsonInclude]
		[JsonPropertyName("num_partitions")]
		public long NumPartitions { get; set; }

		[JsonInclude]
		[JsonPropertyName("partition")]
		public long Partition { get; set; }
	}

	[ConvertAs(typeof(TestPopulation))]
	public partial interface ITestPopulation
	{
		Elastic.Clients.Elasticsearch.Field Field { get; set; }

		Elastic.Clients.Elasticsearch.QueryDsl.IQueryContainer? Filter { get; set; }

		Elastic.Clients.Elasticsearch.Script? Script { get; set; }
	}

	public partial class TestPopulationDescriptor : DescriptorBase<TestPopulationDescriptor, ITestPopulation>, ITestPopulation
	{
		Elastic.Clients.Elasticsearch.Field ITestPopulation.Field { get; set; }

		Elastic.Clients.Elasticsearch.Script? ITestPopulation.Script { get; set; }

		Elastic.Clients.Elasticsearch.QueryDsl.IQueryContainer? ITestPopulation.Filter { get; set; }
	}

	public partial class TestPopulation : ITestPopulation
	{
		[JsonInclude]
		[JsonPropertyName("field")]
		public Elastic.Clients.Elasticsearch.Field Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("filter")]
		public Elastic.Clients.Elasticsearch.QueryDsl.IQueryContainer? Filter { get; set; }

		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script? Script { get; set; }
	}

	public partial class TopHitsAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("hits")]
		public Elastic.Clients.Elasticsearch.Global.Search.HitsMetadata<Dictionary<string, object>> Hits
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	[ConvertAs(typeof(TopHitsAggregation))]
	public partial interface ITopHitsAggregation
	{
		Elastic.Clients.Elasticsearch.Fields? DocvalueFields { get; set; }

		bool? Explain { get; set; }

		int? From { get; set; }

		Elastic.Clients.Elasticsearch.Global.Search.IHighlight? Highlight { get; set; }

		Dictionary<string, Elastic.Clients.Elasticsearch.IScriptField>? ScriptFields { get; set; }

		bool? SeqNoPrimaryTerm { get; set; }

		int? Size { get; set; }

		Elastic.Clients.Elasticsearch.Global.Search.Sort? Sort { get; set; }

		Elastic.Clients.Elasticsearch.Fields? StoredFields { get; set; }

		bool? TrackScores { get; set; }

		bool? Version { get; set; }
	}

	public partial class TopHitsAggregationDescriptor : DescriptorBase<TopHitsAggregationDescriptor, ITopHitsAggregation>, ITopHitsAggregation
	{
		Elastic.Clients.Elasticsearch.Fields? ITopHitsAggregation.DocvalueFields { get; set; }

		bool? ITopHitsAggregation.Explain { get; set; }

		int? ITopHitsAggregation.From { get; set; }

		Elastic.Clients.Elasticsearch.Global.Search.IHighlight? ITopHitsAggregation.Highlight { get; set; }

		Dictionary<string, Elastic.Clients.Elasticsearch.IScriptField>? ITopHitsAggregation.ScriptFields { get; set; }

		int? ITopHitsAggregation.Size { get; set; }

		Elastic.Clients.Elasticsearch.Global.Search.Sort? ITopHitsAggregation.Sort { get; set; }

		Elastic.Clients.Elasticsearch.Fields? ITopHitsAggregation.StoredFields { get; set; }

		bool? ITopHitsAggregation.TrackScores { get; set; }

		bool? ITopHitsAggregation.Version { get; set; }

		bool? ITopHitsAggregation.SeqNoPrimaryTerm { get; set; }
	}

	public partial class TopHitsAggregation : Aggregations.MetricAggregationBase, ITopHitsAggregation
	{
		[JsonInclude]
		[JsonPropertyName("docvalue_fields")]
		public Elastic.Clients.Elasticsearch.Fields? DocvalueFields { get; set; }

		[JsonInclude]
		[JsonPropertyName("explain")]
		public bool? Explain { get; set; }

		[JsonInclude]
		[JsonPropertyName("from")]
		public int? From { get; set; }

		[JsonInclude]
		[JsonPropertyName("highlight")]
		public Elastic.Clients.Elasticsearch.Global.Search.IHighlight? Highlight { get; set; }

		[JsonInclude]
		[JsonPropertyName("script_fields")]
		public Dictionary<string, Elastic.Clients.Elasticsearch.IScriptField>? ScriptFields { get; set; }

		[JsonInclude]
		[JsonPropertyName("seq_no_primary_term")]
		public bool? SeqNoPrimaryTerm { get; set; }

		[JsonInclude]
		[JsonPropertyName("size")]
		public int? Size { get; set; }

		[JsonInclude]
		[JsonPropertyName("sort")]
		public Elastic.Clients.Elasticsearch.Global.Search.Sort? Sort { get; set; }

		[JsonInclude]
		[JsonPropertyName("_source")]
		public OneOf<bool, Global.Search.SourceFilter, Fields>? Source { get; set; }

		[JsonInclude]
		[JsonPropertyName("stored_fields")]
		public Elastic.Clients.Elasticsearch.Fields? StoredFields { get; set; }

		[JsonInclude]
		[JsonPropertyName("track_scores")]
		public bool? TrackScores { get; set; }

		[JsonInclude]
		[JsonPropertyName("version")]
		public bool? Version { get; set; }
	}

	public partial class TopMetrics
	{
		[JsonInclude]
		[JsonPropertyName("metrics")]
		public Dictionary<string, Union<double, string>> Metrics
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("sort")]
		public IReadOnlyCollection<Union<double, string>> Sort
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	public partial class TopMetricsAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("top")]
		public IReadOnlyCollection<Elastic.Clients.Elasticsearch.Aggregations.TopMetrics> Top
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	[ConvertAs(typeof(TopMetricsAggregation))]
	public partial interface ITopMetricsAggregation
	{
		IEnumerable<Elastic.Clients.Elasticsearch.Aggregations.ITopMetricsValue>? Metrics { get; set; }

		int? Size { get; set; }

		Elastic.Clients.Elasticsearch.Global.Search.Sort? Sort { get; set; }
	}

	public partial class TopMetricsAggregationDescriptor : DescriptorBase<TopMetricsAggregationDescriptor, ITopMetricsAggregation>, ITopMetricsAggregation
	{
		IEnumerable<Elastic.Clients.Elasticsearch.Aggregations.ITopMetricsValue>? ITopMetricsAggregation.Metrics { get; set; }

		int? ITopMetricsAggregation.Size { get; set; }

		Elastic.Clients.Elasticsearch.Global.Search.Sort? ITopMetricsAggregation.Sort { get; set; }
	}

	public partial class TopMetricsAggregation : Aggregations.MetricAggregationBase, ITopMetricsAggregation
	{
		[JsonInclude]
		[JsonPropertyName("metrics")]
		public IEnumerable<Elastic.Clients.Elasticsearch.Aggregations.ITopMetricsValue>? Metrics { get; set; }

		[JsonInclude]
		[JsonPropertyName("size")]
		public int? Size { get; set; }

		[JsonInclude]
		[JsonPropertyName("sort")]
		public Elastic.Clients.Elasticsearch.Global.Search.Sort? Sort { get; set; }
	}

	[ConvertAs(typeof(TopMetricsValue))]
	public partial interface ITopMetricsValue
	{
		Elastic.Clients.Elasticsearch.Field Field { get; set; }
	}

	public partial class TopMetricsValueDescriptor : DescriptorBase<TopMetricsValueDescriptor, ITopMetricsValue>, ITopMetricsValue
	{
		Elastic.Clients.Elasticsearch.Field ITopMetricsValue.Field { get; set; }
	}

	public partial class TopMetricsValue : ITopMetricsValue
	{
		[JsonInclude]
		[JsonPropertyName("field")]
		public Elastic.Clients.Elasticsearch.Field Field { get; set; }
	}

	public partial class ValueAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("value")]
		public double Value
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("value_as_string")]
		public string? ValueAsString
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	[ConvertAs(typeof(ValueCountAggregation))]
	public partial interface IValueCountAggregation
	{
	}

	public partial class ValueCountAggregationDescriptor : DescriptorBase<ValueCountAggregationDescriptor, IValueCountAggregation>, IValueCountAggregation
	{
	}

	public partial class ValueCountAggregation : Aggregations.FormattableMetricAggregation, IValueCountAggregation
	{
	}

	[ConvertAs(typeof(VariableWidthHistogramAggregation))]
	public partial interface IVariableWidthHistogramAggregation
	{
		int? Buckets { get; set; }

		Elastic.Clients.Elasticsearch.Field? Field { get; set; }

		int? InitialBuffer { get; set; }

		int? ShardSize { get; set; }
	}

	public partial class VariableWidthHistogramAggregationDescriptor : DescriptorBase<VariableWidthHistogramAggregationDescriptor, IVariableWidthHistogramAggregation>, IVariableWidthHistogramAggregation
	{
		Elastic.Clients.Elasticsearch.Field? IVariableWidthHistogramAggregation.Field { get; set; }

		int? IVariableWidthHistogramAggregation.Buckets { get; set; }

		int? IVariableWidthHistogramAggregation.ShardSize { get; set; }

		int? IVariableWidthHistogramAggregation.InitialBuffer { get; set; }
	}

	public partial class VariableWidthHistogramAggregation : IVariableWidthHistogramAggregation
	{
		[JsonInclude]
		[JsonPropertyName("buckets")]
		public int? Buckets { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public Elastic.Clients.Elasticsearch.Field? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("initial_buffer")]
		public int? InitialBuffer { get; set; }

		[JsonInclude]
		[JsonPropertyName("shard_size")]
		public int? ShardSize { get; set; }
	}

	[ConvertAs(typeof(WeightedAverageAggregation))]
	public partial interface IWeightedAverageAggregation
	{
		string? Format { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.IWeightedAverageValue? Value { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.ValueType? ValueType { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.IWeightedAverageValue? Weight { get; set; }
	}

	public partial class WeightedAverageAggregationDescriptor : DescriptorBase<WeightedAverageAggregationDescriptor, IWeightedAverageAggregation>, IWeightedAverageAggregation
	{
		string? IWeightedAverageAggregation.Format { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.IWeightedAverageValue? IWeightedAverageAggregation.Value { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.ValueType? IWeightedAverageAggregation.ValueType { get; set; }

		Elastic.Clients.Elasticsearch.Aggregations.IWeightedAverageValue? IWeightedAverageAggregation.Weight { get; set; }
	}

	public partial class WeightedAverageAggregation : Aggregations.Aggregation, IWeightedAverageAggregation
	{
		[JsonInclude]
		[JsonPropertyName("format")]
		public string? Format { get; set; }

		[JsonInclude]
		[JsonPropertyName("value")]
		public Elastic.Clients.Elasticsearch.Aggregations.IWeightedAverageValue? Value { get; set; }

		[JsonInclude]
		[JsonPropertyName("value_type")]
		public Elastic.Clients.Elasticsearch.Aggregations.ValueType? ValueType { get; set; }

		[JsonInclude]
		[JsonPropertyName("weight")]
		public Elastic.Clients.Elasticsearch.Aggregations.IWeightedAverageValue? Weight { get; set; }
	}

	[ConvertAs(typeof(WeightedAverageValue))]
	public partial interface IWeightedAverageValue
	{
		Elastic.Clients.Elasticsearch.Field? Field { get; set; }

		double? Missing { get; set; }

		Elastic.Clients.Elasticsearch.Script? Script { get; set; }
	}

	public partial class WeightedAverageValueDescriptor : DescriptorBase<WeightedAverageValueDescriptor, IWeightedAverageValue>, IWeightedAverageValue
	{
		Elastic.Clients.Elasticsearch.Field? IWeightedAverageValue.Field { get; set; }

		double? IWeightedAverageValue.Missing { get; set; }

		Elastic.Clients.Elasticsearch.Script? IWeightedAverageValue.Script { get; set; }
	}

	public partial class WeightedAverageValue : IWeightedAverageValue
	{
		[JsonInclude]
		[JsonPropertyName("field")]
		public Elastic.Clients.Elasticsearch.Field? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing")]
		public double? Missing { get; set; }

		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script? Script { get; set; }
	}
}