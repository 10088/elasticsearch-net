// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information.
//
// ███╗   ██╗ ██████╗ ████████╗██╗ ██████╗███████╗
// ████╗  ██║██╔═══██╗╚══██╔══╝██║██╔════╝██╔════╝
// ██╔██╗ ██║██║   ██║   ██║   ██║██║     █████╗
// ██║╚██╗██║██║   ██║   ██║   ██║██║     ██╔══╝
// ██║ ╚████║╚██████╔╝   ██║   ██║╚██████╗███████╗
// ╚═╝  ╚═══╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝╚══════╝
// ------------------------------------------------
//
// This file is automatically generated.
// Please do not edit these files manually.
//
// ------------------------------------------------

using Elastic.Transport.Products.Elasticsearch.Failures;
using OneOf;
using System;
using System.Collections.Generic;
using System.Text.Json.Serialization;

#nullable restore
namespace Elastic.Clients.Elasticsearch.Analysis
{
	public partial class AsciiFoldingTokenFilter : Analysis.TokenFilterBase
	{
		[JsonInclude]
		[JsonPropertyName("preserve_original")]
		public bool PreserveOriginal
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "asciifolding";
	}

	public abstract partial class CharFilterBase
	{
		[JsonInclude]
		[JsonPropertyName("version")]
		public Elastic.Clients.Elasticsearch.VersionString? Version
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	public partial class CharGroupTokenizer : Analysis.TokenizerBase
	{
		[JsonInclude]
		[JsonPropertyName("tokenize_on_chars")]
		public IReadOnlyCollection<string> TokenizeOnChars
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "char_group";
	}

	public partial class CommonGramsTokenFilter : Analysis.TokenFilterBase
	{
		[JsonInclude]
		[JsonPropertyName("common_words")]
		public IReadOnlyCollection<string> CommonWords
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("common_words_path")]
		public string CommonWordsPath
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("ignore_case")]
		public bool IgnoreCase
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("query_mode")]
		public bool QueryMode
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "common_grams";
	}

	public abstract partial class CompoundWordTokenFilterBase : Analysis.TokenFilterBase
	{
		[JsonInclude]
		[JsonPropertyName("hyphenation_patterns_path")]
		public string HyphenationPatternsPath
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("max_subword_size")]
		public int MaxSubwordSize
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("min_subword_size")]
		public int MinSubwordSize
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("min_word_size")]
		public int MinWordSize
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("only_longest_match")]
		public bool OnlyLongestMatch
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("word_list")]
		public IReadOnlyCollection<string> WordList
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("word_list_path")]
		public string WordListPath
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	public partial class ConditionTokenFilter : Analysis.TokenFilterBase
	{
		[JsonInclude]
		[JsonPropertyName("filter")]
		public IReadOnlyCollection<string> Filter
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script Script
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "condition";
	}

	public partial class CustomAnalyzer
	{
		[JsonInclude]
		[JsonPropertyName("char_filter")]
		public IReadOnlyCollection<string>? CharFilter
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("filter")]
		public IReadOnlyCollection<string>? Filter
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("position_increment_gap")]
		public int? PositionIncrementGap
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("position_offset_gap")]
		public int? PositionOffsetGap
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("tokenizer")]
		public string Tokenizer
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "custom";
	}

	[ConvertAs(typeof(CustomNormalizer))]
	public partial interface ICustomNormalizer
	{
		IEnumerable<string>? CharFilter { get; set; }

		IEnumerable<string>? Filter { get; set; }
	}

	public partial class CustomNormalizerDescriptor : DescriptorBase<CustomNormalizerDescriptor, ICustomNormalizer>, ICustomNormalizer
	{
		IEnumerable<string>? ICustomNormalizer.CharFilter { get; set; }

		IEnumerable<string>? ICustomNormalizer.Filter { get; set; }
	}

	public partial class CustomNormalizer : ICustomNormalizer
	{
		[JsonInclude]
		[JsonPropertyName("char_filter")]
		public IEnumerable<string>? CharFilter { get; set; }

		[JsonInclude]
		[JsonPropertyName("filter")]
		public IEnumerable<string>? Filter { get; set; }

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "custom";
	}

	public partial class DelimitedPayloadTokenFilter : Analysis.TokenFilterBase
	{
		[JsonInclude]
		[JsonPropertyName("delimiter")]
		public string Delimiter
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("encoding")]
		public Elastic.Clients.Elasticsearch.Analysis.DelimitedPayloadEncoding Encoding
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "delimited_payload";
	}

	public partial class EdgeNGramTokenFilter : Analysis.TokenFilterBase
	{
		[JsonInclude]
		[JsonPropertyName("max_gram")]
		public int MaxGram
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("min_gram")]
		public int MinGram
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("side")]
		public Elastic.Clients.Elasticsearch.Analysis.EdgeNGramSide Side
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "edge_ngram";
	}

	public partial class EdgeNGramTokenizer : Analysis.TokenizerBase
	{
		[JsonInclude]
		[JsonPropertyName("custom_token_chars")]
		public string CustomTokenChars
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("max_gram")]
		public int MaxGram
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("min_gram")]
		public int MinGram
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("token_chars")]
		public IReadOnlyCollection<Elastic.Clients.Elasticsearch.Analysis.TokenChar> TokenChars
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "edge_ngram";
	}

	public partial class ElisionTokenFilter : Analysis.TokenFilterBase
	{
		[JsonInclude]
		[JsonPropertyName("articles")]
		public IReadOnlyCollection<string> Articles
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("articles_case")]
		public bool ArticlesCase
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "elision";
	}

	public partial class FingerprintAnalyzer
	{
		[JsonInclude]
		[JsonPropertyName("max_output_size")]
		public int MaxOutputSize
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("preserve_original")]
		public bool PreserveOriginal
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("separator")]
		public string Separator
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("stopwords")]
		public Elastic.Clients.Elasticsearch.Analysis.StopWords Stopwords
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("stopwords_path")]
		public string StopwordsPath
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "fingerprint";
		[JsonInclude]
		[JsonPropertyName("version")]
		public Elastic.Clients.Elasticsearch.VersionString Version
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	public partial class FingerprintTokenFilter : Analysis.TokenFilterBase
	{
		[JsonInclude]
		[JsonPropertyName("max_output_size")]
		public int MaxOutputSize
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("separator")]
		public string Separator
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "fingerprint";
	}

	public partial class HtmlStripCharFilter : Analysis.CharFilterBase
	{
		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "html_strip";
	}

	public partial class HunspellTokenFilter : Analysis.TokenFilterBase
	{
		[JsonInclude]
		[JsonPropertyName("dedup")]
		public bool Dedup
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("dictionary")]
		public string Dictionary
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("locale")]
		public string Locale
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("longest_only")]
		public bool LongestOnly
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "hunspell";
	}

	public partial class HyphenationDecompounderTokenFilter : Analysis.CompoundWordTokenFilterBase
	{
		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "hyphenation_decompounder";
	}

	public partial class IcuAnalyzer
	{
		[JsonInclude]
		[JsonPropertyName("method")]
		public Elastic.Clients.Elasticsearch.Analysis.IcuNormalizationType Method
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("mode")]
		public Elastic.Clients.Elasticsearch.Analysis.IcuNormalizationMode Mode
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "icu_analyzer";
	}

	public partial class KStemTokenFilter : Analysis.TokenFilterBase
	{
		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "kstem";
	}

	public partial class KeepTypesTokenFilter : Analysis.TokenFilterBase
	{
		[JsonInclude]
		[JsonPropertyName("mode")]
		public Elastic.Clients.Elasticsearch.Analysis.KeepTypesMode Mode
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "keep_types";
		[JsonInclude]
		[JsonPropertyName("types")]
		public IReadOnlyCollection<string> Types
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	public partial class KeepWordsTokenFilter : Analysis.TokenFilterBase
	{
		[JsonInclude]
		[JsonPropertyName("keep_words")]
		public IReadOnlyCollection<string> KeepWords
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("keep_words_case")]
		public bool KeepWordsCase
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("keep_words_path")]
		public string KeepWordsPath
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "keep";
	}

	public partial class KeywordAnalyzer
	{
		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "keyword";
		[JsonInclude]
		[JsonPropertyName("version")]
		public Elastic.Clients.Elasticsearch.VersionString Version
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	public partial class KeywordMarkerTokenFilter : Analysis.TokenFilterBase
	{
		[JsonInclude]
		[JsonPropertyName("ignore_case")]
		public bool IgnoreCase
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("keywords")]
		public IReadOnlyCollection<string> Keywords
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("keywords_path")]
		public string KeywordsPath
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("keywords_pattern")]
		public string KeywordsPattern
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "keyword_marker";
	}

	public partial class KeywordTokenizer : Analysis.TokenizerBase
	{
		[JsonInclude]
		[JsonPropertyName("buffer_size")]
		public int BufferSize
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "keyword";
	}

	public partial class KuromojiAnalyzer
	{
		[JsonInclude]
		[JsonPropertyName("mode")]
		public Elastic.Clients.Elasticsearch.Analysis.KuromojiTokenizationMode Mode
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "kuromoji";
		[JsonInclude]
		[JsonPropertyName("user_dictionary")]
		public string UserDictionary
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	public partial class KuromojiPartOfSpeechTokenFilter : Analysis.TokenFilterBase
	{
		[JsonInclude]
		[JsonPropertyName("stoptags")]
		public IReadOnlyCollection<string> Stoptags
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "kuromoji_part_of_speech";
	}

	public partial class KuromojiReadingFormTokenFilter : Analysis.TokenFilterBase
	{
		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "kuromoji_readingform";
		[JsonInclude]
		[JsonPropertyName("use_romaji")]
		public bool UseRomaji
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	public partial class KuromojiStemmerTokenFilter : Analysis.TokenFilterBase
	{
		[JsonInclude]
		[JsonPropertyName("minimum_length")]
		public int MinimumLength
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "kuromoji_stemmer";
	}

	public partial class KuromojiTokenizer : Analysis.TokenizerBase
	{
		[JsonInclude]
		[JsonPropertyName("discard_punctuation")]
		public bool DiscardPunctuation
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("mode")]
		public Elastic.Clients.Elasticsearch.Analysis.KuromojiTokenizationMode Mode
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("nbest_cost")]
		public int NbestCost
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("nbest_examples")]
		public string NbestExamples
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "kuromoji_tokenizer";
		[JsonInclude]
		[JsonPropertyName("user_dictionary")]
		public string UserDictionary
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("user_dictionary_rules")]
		public IReadOnlyCollection<string> UserDictionaryRules
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	public partial class LanguageAnalyzer
	{
		[JsonInclude]
		[JsonPropertyName("language")]
		public Elastic.Clients.Elasticsearch.Analysis.Language Language
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("stem_exclusion")]
		public IReadOnlyCollection<string> StemExclusion
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("stopwords")]
		public Elastic.Clients.Elasticsearch.Analysis.StopWords Stopwords
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("stopwords_path")]
		public string StopwordsPath
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "language";
		[JsonInclude]
		[JsonPropertyName("version")]
		public Elastic.Clients.Elasticsearch.VersionString Version
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	public partial class LengthTokenFilter : Analysis.TokenFilterBase
	{
		[JsonInclude]
		[JsonPropertyName("max")]
		public int Max
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("min")]
		public int Min
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "length";
	}

	public partial class LetterTokenizer : Analysis.TokenizerBase
	{
		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "letter";
	}

	public partial class LimitTokenCountTokenFilter : Analysis.TokenFilterBase
	{
		[JsonInclude]
		[JsonPropertyName("consume_all_tokens")]
		public bool ConsumeAllTokens
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("max_token_count")]
		public int MaxTokenCount
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "limit";
	}

	public partial class LowercaseTokenFilter : Analysis.TokenFilterBase
	{
		[JsonInclude]
		[JsonPropertyName("language")]
		public string Language
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "lowercase";
	}

	public partial class LowercaseTokenizer : Analysis.TokenizerBase
	{
		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "lowercase";
	}

	public partial class MappingCharFilter : Analysis.CharFilterBase
	{
		[JsonInclude]
		[JsonPropertyName("mappings")]
		public IReadOnlyCollection<string> Mappings
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("mappings_path")]
		public string MappingsPath
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "mapping";
	}

	public partial class MultiplexerTokenFilter : Analysis.TokenFilterBase
	{
		[JsonInclude]
		[JsonPropertyName("filters")]
		public IReadOnlyCollection<string> Filters
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("preserve_original")]
		public bool PreserveOriginal
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "multiplexer";
	}

	public partial class NGramTokenFilter : Analysis.TokenFilterBase
	{
		[JsonInclude]
		[JsonPropertyName("max_gram")]
		public int MaxGram
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("min_gram")]
		public int MinGram
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "ngram";
	}

	public partial class NGramTokenizer : Analysis.TokenizerBase
	{
		[JsonInclude]
		[JsonPropertyName("custom_token_chars")]
		public string CustomTokenChars
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("max_gram")]
		public int MaxGram
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("min_gram")]
		public int MinGram
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("token_chars")]
		public IReadOnlyCollection<Elastic.Clients.Elasticsearch.Analysis.TokenChar> TokenChars
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "ngram";
	}

	public partial class NoriAnalyzer
	{
		[JsonInclude]
		[JsonPropertyName("decompound_mode")]
		public Elastic.Clients.Elasticsearch.Analysis.NoriDecompoundMode DecompoundMode
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("stoptags")]
		public IReadOnlyCollection<string> Stoptags
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "nori";
		[JsonInclude]
		[JsonPropertyName("user_dictionary")]
		public string UserDictionary
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("version")]
		public Elastic.Clients.Elasticsearch.VersionString Version
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	public partial class NoriPartOfSpeechTokenFilter : Analysis.TokenFilterBase
	{
		[JsonInclude]
		[JsonPropertyName("stoptags")]
		public IReadOnlyCollection<string> Stoptags
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "nori_part_of_speech";
	}

	public partial class NoriTokenizer : Analysis.TokenizerBase
	{
		[JsonInclude]
		[JsonPropertyName("decompound_mode")]
		public Elastic.Clients.Elasticsearch.Analysis.NoriDecompoundMode DecompoundMode
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("discard_punctuation")]
		public bool DiscardPunctuation
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "nori_tokenizer";
		[JsonInclude]
		[JsonPropertyName("user_dictionary")]
		public string UserDictionary
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("user_dictionary_rules")]
		public IReadOnlyCollection<string> UserDictionaryRules
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	public partial class PathHierarchyTokenizer : Analysis.TokenizerBase
	{
		[JsonInclude]
		[JsonPropertyName("buffer_size")]
		public int BufferSize
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("delimiter")]
		public string Delimiter
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("replacement")]
		public string Replacement
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("reverse")]
		public bool Reverse
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("skip")]
		public int Skip
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "path_hierarchy";
	}

	public partial class PatternAnalyzer
	{
		[JsonInclude]
		[JsonPropertyName("flags")]
		public string Flags
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("lowercase")]
		public bool Lowercase
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("pattern")]
		public string Pattern
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("stopwords")]
		public Elastic.Clients.Elasticsearch.Analysis.StopWords Stopwords
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "pattern";
		[JsonInclude]
		[JsonPropertyName("version")]
		public Elastic.Clients.Elasticsearch.VersionString Version
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	public partial class PatternCaptureTokenFilter : Analysis.TokenFilterBase
	{
		[JsonInclude]
		[JsonPropertyName("patterns")]
		public IReadOnlyCollection<string> Patterns
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("preserve_original")]
		public bool PreserveOriginal
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "pattern_capture";
	}

	public partial class PatternReplaceTokenFilter : Analysis.TokenFilterBase
	{
		[JsonInclude]
		[JsonPropertyName("flags")]
		public string Flags
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("pattern")]
		public string Pattern
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("replacement")]
		public string Replacement
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "pattern_replace";
	}

	public partial class PorterStemTokenFilter : Analysis.TokenFilterBase
	{
		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "porter_stem";
	}

	public partial class PredicateTokenFilter : Analysis.TokenFilterBase
	{
		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script Script
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "predicate_token_filter";
	}

	public partial class RemoveDuplicatesTokenFilter : Analysis.TokenFilterBase
	{
		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "remove_duplicates";
	}

	public partial class ReverseTokenFilter : Analysis.TokenFilterBase
	{
		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "reverse";
	}

	public partial class ShingleTokenFilter : Analysis.TokenFilterBase
	{
		[JsonInclude]
		[JsonPropertyName("filler_token")]
		public string FillerToken
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("max_shingle_size")]
		public int MaxShingleSize
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("min_shingle_size")]
		public int MinShingleSize
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("output_unigrams")]
		public bool OutputUnigrams
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("output_unigrams_if_no_shingles")]
		public bool OutputUnigramsIfNoShingles
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("token_separator")]
		public string TokenSeparator
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "shingle";
	}

	public partial class SimpleAnalyzer
	{
		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "simple";
		[JsonInclude]
		[JsonPropertyName("version")]
		public Elastic.Clients.Elasticsearch.VersionString Version
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	public partial class SnowballTokenFilter : Analysis.TokenFilterBase
	{
		[JsonInclude]
		[JsonPropertyName("language")]
		public Elastic.Clients.Elasticsearch.Analysis.SnowballLanguage Language
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "snowball";
	}

	public partial class StandardAnalyzer
	{
		[JsonInclude]
		[JsonPropertyName("max_token_length")]
		public int MaxTokenLength
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("stopwords")]
		public Elastic.Clients.Elasticsearch.Analysis.StopWords Stopwords
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "standard";
	}

	public partial class StandardTokenizer : Analysis.TokenizerBase
	{
		[JsonInclude]
		[JsonPropertyName("max_token_length")]
		public int MaxTokenLength
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "standard";
	}

	public partial class StemmerOverrideTokenFilter : Analysis.TokenFilterBase
	{
		[JsonInclude]
		[JsonPropertyName("rules")]
		public IReadOnlyCollection<string> Rules
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("rules_path")]
		public string RulesPath
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "stemmer_override";
	}

	public partial class StemmerTokenFilter : Analysis.TokenFilterBase
	{
		[JsonInclude]
		[JsonPropertyName("language")]
		public string Language
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "stemmer";
	}

	public partial class StopAnalyzer
	{
		[JsonInclude]
		[JsonPropertyName("stopwords")]
		public Elastic.Clients.Elasticsearch.Analysis.StopWords Stopwords
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("stopwords_path")]
		public string StopwordsPath
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "stop";
		[JsonInclude]
		[JsonPropertyName("version")]
		public Elastic.Clients.Elasticsearch.VersionString Version
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	public partial class StopTokenFilter : Analysis.TokenFilterBase
	{
		[JsonInclude]
		[JsonPropertyName("ignore_case")]
		public bool? IgnoreCase
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("remove_trailing")]
		public bool? RemoveTrailing
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("stopwords")]
		public Elastic.Clients.Elasticsearch.Analysis.StopWords Stopwords
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("stopwords_path")]
		public string? StopwordsPath
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "stop";
	}

	public partial class SynonymGraphTokenFilter : Analysis.TokenFilterBase
	{
		[JsonInclude]
		[JsonPropertyName("expand")]
		public bool Expand
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("format")]
		public Elastic.Clients.Elasticsearch.Analysis.SynonymFormat Format
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("lenient")]
		public bool Lenient
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("synonyms")]
		public IReadOnlyCollection<string> Synonyms
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("synonyms_path")]
		public string SynonymsPath
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("tokenizer")]
		public string Tokenizer
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "synonym_graph";
		[JsonInclude]
		[JsonPropertyName("updateable")]
		public bool Updateable
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	public partial class SynonymTokenFilter : Analysis.TokenFilterBase
	{
		[JsonInclude]
		[JsonPropertyName("expand")]
		public bool Expand
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("format")]
		public Elastic.Clients.Elasticsearch.Analysis.SynonymFormat Format
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("lenient")]
		public bool Lenient
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("synonyms")]
		public IReadOnlyCollection<string> Synonyms
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("synonyms_path")]
		public string SynonymsPath
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("tokenizer")]
		public string Tokenizer
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "synonym";
		[JsonInclude]
		[JsonPropertyName("updateable")]
		public bool Updateable
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	public abstract partial class TokenFilterBase
	{
		[JsonInclude]
		[JsonPropertyName("version")]
		public Elastic.Clients.Elasticsearch.VersionString? Version
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	public abstract partial class TokenizerBase
	{
		[JsonInclude]
		[JsonPropertyName("version")]
		public Elastic.Clients.Elasticsearch.VersionString? Version
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	public partial class TrimTokenFilter : Analysis.TokenFilterBase
	{
		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "trim";
	}

	public partial class TruncateTokenFilter : Analysis.TokenFilterBase
	{
		[JsonInclude]
		[JsonPropertyName("length")]
		public int Length
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "truncate";
	}

	public partial class UaxEmailUrlTokenizer : Analysis.TokenizerBase
	{
		[JsonInclude]
		[JsonPropertyName("max_token_length")]
		public int MaxTokenLength
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "uax_url_email";
	}

	public partial class UniqueTokenFilter : Analysis.TokenFilterBase
	{
		[JsonInclude]
		[JsonPropertyName("only_on_same_position")]
		public bool OnlyOnSamePosition
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "unique";
	}

	public partial class UppercaseTokenFilter : Analysis.TokenFilterBase
	{
		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "uppercase";
	}

	public partial class WhitespaceAnalyzer
	{
		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "whitespace";
		[JsonInclude]
		[JsonPropertyName("version")]
		public Elastic.Clients.Elasticsearch.VersionString Version
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	public partial class WhitespaceTokenizer : Analysis.TokenizerBase
	{
		[JsonInclude]
		[JsonPropertyName("max_token_length")]
		public int MaxTokenLength
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "whitespace";
	}

	public partial class WordDelimiterGraphTokenFilter : Analysis.TokenFilterBase
	{
		[JsonInclude]
		[JsonPropertyName("adjust_offsets")]
		public bool AdjustOffsets
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("catenate_all")]
		public bool CatenateAll
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("catenate_numbers")]
		public bool CatenateNumbers
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("catenate_words")]
		public bool CatenateWords
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("generate_number_parts")]
		public bool GenerateNumberParts
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("generate_word_parts")]
		public bool GenerateWordParts
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("preserve_original")]
		public bool PreserveOriginal
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("protected_words")]
		public IReadOnlyCollection<string> ProtectedWords
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("protected_words_path")]
		public string ProtectedWordsPath
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("split_on_case_change")]
		public bool SplitOnCaseChange
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("split_on_numerics")]
		public bool SplitOnNumerics
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("stem_english_possessive")]
		public bool StemEnglishPossessive
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "word_delimiter_graph";
		[JsonInclude]
		[JsonPropertyName("type_table")]
		public IReadOnlyCollection<string> TypeTable
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type_table_path")]
		public string TypeTablePath
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}

	public partial class WordDelimiterTokenFilter : Analysis.TokenFilterBase
	{
		[JsonInclude]
		[JsonPropertyName("catenate_all")]
		public bool CatenateAll
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("catenate_numbers")]
		public bool CatenateNumbers
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("catenate_words")]
		public bool CatenateWords
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("generate_number_parts")]
		public bool GenerateNumberParts
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("generate_word_parts")]
		public bool GenerateWordParts
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("preserve_original")]
		public bool PreserveOriginal
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("protected_words")]
		public IReadOnlyCollection<string> ProtectedWords
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("protected_words_path")]
		public string ProtectedWordsPath
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("split_on_case_change")]
		public bool SplitOnCaseChange
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("split_on_numerics")]
		public bool SplitOnNumerics
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("stem_english_possessive")]
		public bool StemEnglishPossessive
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "word_delimiter";
		[JsonInclude]
		[JsonPropertyName("type_table")]
		public IReadOnlyCollection<string> TypeTable
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}

		[JsonInclude]
		[JsonPropertyName("type_table_path")]
		public string TypeTablePath
		{
			get;
#if NET5_0_OR_GREATER
			init;
#else
			internal set;
#endif
		}
	}
}