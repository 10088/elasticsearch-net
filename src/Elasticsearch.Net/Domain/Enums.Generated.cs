
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Runtime.Serialization;

///This file contains all the typed enums that the client rest api spec exposes.
///This file is automatically generated from https://github.com/elasticsearch/elasticsearch-rest-api-spec
///Generated of commit 
namespace Elasticsearch.Net
{
	
	
	public enum Consistency 
	{
		  [EnumMember(Value = "one")]
		One,
		[EnumMember(Value = "quorum")]
		Quorum,
		[EnumMember(Value = "all")]
		All
	}
	
	
	public enum Replication 
	{
		  [EnumMember(Value = "sync")]
		Sync,
		[EnumMember(Value = "async")]
		Async
	}
	
	
	public enum Bytes 
	{
		  [EnumMember(Value = "b")]
		B,
		[EnumMember(Value = "k")]
		K,
		[EnumMember(Value = "m")]
		M,
		[EnumMember(Value = "g")]
		G
	}
	
	
	public enum Level 
	{
		  [EnumMember(Value = "cluster")]
		Cluster,
		[EnumMember(Value = "indices")]
		Indices,
		[EnumMember(Value = "shards")]
		Shards
	}
	
	
	public enum WaitForStatus 
	{
		  [EnumMember(Value = "green")]
		Green,
		[EnumMember(Value = "yellow")]
		Yellow,
		[EnumMember(Value = "red")]
		Red
	}
	
	
	public enum ExpandWildcards 
	{
		  [EnumMember(Value = "open")]
		Open,
		[EnumMember(Value = "closed")]
		Closed,
		[EnumMember(Value = "none")]
		None,
		[EnumMember(Value = "all")]
		All
	}
	
	
	public enum DefaultOperator 
	{
		  [EnumMember(Value = "AND")]
		And,
		[EnumMember(Value = "OR")]
		Or
	}
	
	
	public enum VersionType 
	{
		  [EnumMember(Value = "internal")]
		Internal,
		[EnumMember(Value = "external")]
		External,
		[EnumMember(Value = "external_gte")]
		ExternalGte,
		[EnumMember(Value = "force")]
		Force
	}
	
	
	public enum OpType 
	{
		  [EnumMember(Value = "index")]
		Index,
		[EnumMember(Value = "create")]
		Create
	}
	
	
	public enum Format 
	{
		  [EnumMember(Value = "detailed")]
		Detailed,
		[EnumMember(Value = "text")]
		Text
	}
	
	
	public enum SearchType 
	{
		  [EnumMember(Value = "query_then_fetch")]
		QueryThenFetch,
		[EnumMember(Value = "query_and_fetch")]
		QueryAndFetch,
		[EnumMember(Value = "dfs_query_then_fetch")]
		DfsQueryThenFetch,
		[EnumMember(Value = "dfs_query_and_fetch")]
		DfsQueryAndFetch,
		[EnumMember(Value = "count")]
		Count,
		[EnumMember(Value = "scan")]
		Scan
	}
	
	
	public enum ThreadType 
	{
		  [EnumMember(Value = "cpu")]
		Cpu,
		[EnumMember(Value = "wait")]
		Wait,
		[EnumMember(Value = "block")]
		Block
	}
	
	
	public enum PercolateFormat 
	{
		  [EnumMember(Value = "ids")]
		Ids
	}
	
	
	public enum SuggestMode 
	{
		  [EnumMember(Value = "missing")]
		Missing,
		[EnumMember(Value = "popular")]
		Popular,
		[EnumMember(Value = "always")]
		Always
	}
	

	public static class KnownEnums
	{
		public static string Resolve(Enum e)
		{
			
			if (e is Consistency)
			{
				switch((Consistency)e)
				{
					case Consistency.One: return "one";
					case Consistency.Quorum: return "quorum";
					case Consistency.All: return "all";
				}
			}
			
			
			if (e is Replication)
			{
				switch((Replication)e)
				{
					case Replication.Sync: return "sync";
					case Replication.Async: return "async";
				}
			}
			
			
			if (e is Bytes)
			{
				switch((Bytes)e)
				{
					case Bytes.B: return "b";
					case Bytes.K: return "k";
					case Bytes.M: return "m";
					case Bytes.G: return "g";
				}
			}
			
			
			if (e is Level)
			{
				switch((Level)e)
				{
					case Level.Cluster: return "cluster";
					case Level.Indices: return "indices";
					case Level.Shards: return "shards";
				}
			}
			
			
			if (e is WaitForStatus)
			{
				switch((WaitForStatus)e)
				{
					case WaitForStatus.Green: return "green";
					case WaitForStatus.Yellow: return "yellow";
					case WaitForStatus.Red: return "red";
				}
			}
			
			
			if (e is ExpandWildcards)
			{
				switch((ExpandWildcards)e)
				{
					case ExpandWildcards.Open: return "open";
					case ExpandWildcards.Closed: return "closed";
					case ExpandWildcards.None: return "none";
					case ExpandWildcards.All: return "all";
				}
			}
			
			
			if (e is DefaultOperator)
			{
				switch((DefaultOperator)e)
				{
					case DefaultOperator.And: return "AND";
					case DefaultOperator.Or: return "OR";
				}
			}
			
			
			if (e is VersionType)
			{
				switch((VersionType)e)
				{
					case VersionType.Internal: return "internal";
					case VersionType.External: return "external";
					case VersionType.ExternalGte: return "external_gte";
					case VersionType.Force: return "force";
				}
			}
			
			
			if (e is OpType)
			{
				switch((OpType)e)
				{
					case OpType.Index: return "index";
					case OpType.Create: return "create";
				}
			}
			
			
			if (e is Format)
			{
				switch((Format)e)
				{
					case Format.Detailed: return "detailed";
					case Format.Text: return "text";
				}
			}
			
			
			if (e is SearchType)
			{
				switch((SearchType)e)
				{
					case SearchType.QueryThenFetch: return "query_then_fetch";
					case SearchType.QueryAndFetch: return "query_and_fetch";
					case SearchType.DfsQueryThenFetch: return "dfs_query_then_fetch";
					case SearchType.DfsQueryAndFetch: return "dfs_query_and_fetch";
					case SearchType.Count: return "count";
					case SearchType.Scan: return "scan";
				}
			}
			
			
			if (e is ThreadType)
			{
				switch((ThreadType)e)
				{
					case ThreadType.Cpu: return "cpu";
					case ThreadType.Wait: return "wait";
					case ThreadType.Block: return "block";
				}
			}
			
			
			if (e is PercolateFormat)
			{
				switch((PercolateFormat)e)
				{
					case PercolateFormat.Ids: return "ids";
				}
			}
			
			
			if (e is SuggestMode)
			{
				switch((SuggestMode)e)
				{
					case SuggestMode.Missing: return "missing";
					case SuggestMode.Popular: return "popular";
					case SuggestMode.Always: return "always";
				}
			}
			
			return "UNKNOWNENUM";
		}
	}
}
 